<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://ykkim97.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ykkim97.github.io/" rel="alternate" type="text/html" /><updated>2022-08-07T23:01:42+09:00</updated><id>https://ykkim97.github.io/feed.xml</id><title type="html">YoungGwon’s IT Tech Blog</title><subtitle>IT 기술 블로그입니다.</subtitle><entry><title type="html">Git Flow 전략에 대해(브랜치 관리 전략)</title><link href="https://ykkim97.github.io/git-gitflow" rel="alternate" type="text/html" title="Git Flow 전략에 대해(브랜치 관리 전략)" /><published>2022-08-06T03:32:00+09:00</published><updated>2022-08-06T03:32:00+09:00</updated><id>https://ykkim97.github.io/git-gitflow</id><content type="html" xml:base="https://ykkim97.github.io/git-gitflow">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Git은 다음과 같이 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./git-githubissuelabel&quot;&gt;Github Label별 의미&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./git-gitaddcommit&quot;&gt;git add , commit, 그리고 staging&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./git-gitflow&quot;&gt;Git Flow 전략에 대해(브랜치 관리 전략)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
개발한 코드를 git으로 관리할 때 그냥 main(master)브랜치에 관리하는 것은 좋지 않을 수 있습니다. 특히나 규모가 큰 프로젝트에서 말이죠.
물론 상황에 따라서 다를 수 있습니다.
&lt;br /&gt;&lt;br /&gt;
오늘은 많이 사용하는 브랜치 전략인 git Flow 전략을 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;git-flow-전략&quot;&gt;Git Flow 전략&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/17917009/183293592-2d3ed3f0-556e-490a-b709-8b83294c14f4.JPG&quot; alt=&quot;git flow 전략&quot; width=&quot;840&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 그린 것을 보고 정리해보겠습니다.&lt;br /&gt;
&lt;br /&gt;
일단 현재 배포중인 최종본은 Main(Master)브랜치에서 관리합니다.
이후에 개발을 할 때 git flow 전략은 이 Main 브랜치에서 develop 브랜치를 하나 생성하여 개발을 진행합니다. 
&lt;br /&gt; 
&lt;br /&gt; 
이후 신규 기능을 개발할 때, 이 develop브랜치에서 feature브랜치를 추가로 생성합니다. 만약 로그인 기능을 개발하는 브랜치라면 “feature/login” 과 같은 이름으로 브랜치를 생성합니다.
기능 개발을 완료하고 정상적으로 작동하는지 검토한 후 에 develop브랜치와 이 브랜치를 병합합니다.
&lt;br /&gt; 
&lt;br /&gt; 
새로운 기능이 추가된 develop브랜치를 바로 Main브랜치와 합치기 전에 release 브랜치를 생성하는데, 이것은 이번 출시 버전을 준비하는 브랜치로, 배포전 최종적으로 확인하기위한 브랜치입니다.
&lt;br /&gt; 
&lt;br /&gt; 
이후 최종테스트를 마친 후에, Main으로 배포하게 됩니다. 물론 release 브랜치는 Main브랜치 뿐만 아니라 develop브랜치와도 병합합니다.
&lt;br /&gt; 
&lt;br /&gt; 
배포 버전에서 갑작스러운 버그가 발생하여 급하게 수정해야하는 경우도 있을 것입니다. 이런 경우에는 Main브랜치에서 바로 hotfix라는 브랜치를 생성하여 버그를 수정한 후 바로 Main과 병합하여 배포하게 됩니다. (develop브랜치와도 병합)&lt;/p&gt;

&lt;h2 id=&quot;장점&quot;&gt;장점&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
이 git flow 전략의 장점이 뭘까요?&lt;br /&gt;
신중하게 관리하는 전략이기 때문에 안정적인 배포가 가능하다는 점입니다.&lt;/p&gt;

&lt;h2 id=&quot;정리하기&quot;&gt;정리하기&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
크게 5가지 브랜치로 관리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(main)master : 배포중인 브랜치&lt;/li&gt;
  &lt;li&gt;develop : 다음 출시 버전 개발하는 브랜치&lt;/li&gt;
  &lt;li&gt;feature : 기능을 개발하는 브랜치&lt;/li&gt;
  &lt;li&gt;release : 이번 출시 버전 준비하는 브랜치&lt;/li&gt;
  &lt;li&gt;hotfix : 출시중인 버전에서 발생한 버그를 수정하는 브랜치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="git" /><summary type="html">Git은 다음과 같이 구성되어 있습니다. Github Label별 의미 git add , commit, 그리고 staging Git Flow 전략에 대해(브랜치 관리 전략)</summary></entry><entry><title type="html">함수선언식과 함수표현식</title><link href="https://ykkim97.github.io/javascript-functionExpression" rel="alternate" type="text/html" title="함수선언식과 함수표현식" /><published>2022-08-04T06:02:00+09:00</published><updated>2022-08-04T06:02:00+09:00</updated><id>https://ykkim97.github.io/javascript-functionExpression</id><content type="html" xml:base="https://ykkim97.github.io/javascript-functionExpression">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;JavaScript 관련 글입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-eventloop&quot;&gt;JS Event Loop, 자바스크립트 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-hoisting&quot;&gt;호이스팅이란 , var, let, const 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-AboutThreejs&quot;&gt;Three.js에 대해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-scripttag&quot;&gt;script, script async, script defer의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-aboutajax&quot;&gt;AJAX가 무엇일까?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-functionExpression&quot;&gt;함수선언식과 함수표현식&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 함수선언식과 함수표현식에 대해서 간단히 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;함수선언식&quot;&gt;함수선언식&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
함수선언식이란 “function” 키워드를 사용해서 함수를 정의하는 방법입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그냥 우리가 기본적으로 알고있는 방식입니다.&lt;/p&gt;

&lt;h2 id=&quot;함수-표현식&quot;&gt;함수 표현식&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
함수표현식은 별도의 변수에 함수를 할당하는 방식입니다.
자바스크립트에서는 함수도 하나의 값으로 취급될 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위처럼 hello라는 변수에 함수를 할당합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;보통은 익명함수를 사용하며 화살표함수를 많이 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;차이점&quot;&gt;차이점&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
함수선언식과 함수표현식의 차이점은 무엇일까요?
이는 호이스팅에 영향을 받는지에 차이가 있습니다.
&lt;br /&gt;&lt;br /&gt;
함수선언식은 호이스팅에 영향을 받고, 함수표현식은 호이스팅에 영향을 받지 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hello함수를 호출하고 이후 함수선언식을 통해서 hello함수를 선언하면 호이스팅이 되기 때문에 에러가 발생하지 않고 정상적으로 실행됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반면 위처럼 함수표현식형태로 했을 경우 호이스팅이 되지 않기 떄문에 에러가 발생하게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수선언식이란 “function” 키워드를 사용해서 함수를 정의하는 방법입니다.&lt;/li&gt;
  &lt;li&gt;함수표현식은 별도의 변수에 함수를 할당하는 방식입니다.&lt;/li&gt;
  &lt;li&gt;함수선언식은 호이스팅에 영향을 받고, 함수표현식은 호이스팅에 영향을 받지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="javascript" /><summary type="html">JavaScript 관련 글입니다. JS Event Loop, 자바스크립트 동작 원리 호이스팅이란 , var, let, const 차이 Three.js에 대해 script, script async, script defer의 차이 AJAX가 무엇일까? 함수선언식과 함수표현식</summary></entry><entry><title type="html">Sass - CSS 전처리기</title><link href="https://ykkim97.github.io/css-sass" rel="alternate" type="text/html" title="Sass - CSS 전처리기" /><published>2022-07-24T15:35:00+09:00</published><updated>2022-07-24T15:35:00+09:00</updated><id>https://ykkim97.github.io/css-sass</id><content type="html" xml:base="https://ykkim97.github.io/css-sass">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;CSS는 다음과 같이 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./css-basic&quot;&gt;CSS의 의미와 적용방법&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-blockinline&quot;&gt;block과 inline의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-emAndRem&quot;&gt;em과 rem의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-sass&quot;&gt;Sass - CSS 전처리기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 Sass가 뭔지 정리해보겠습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;CSS는 스타일을 넣어주는 역할을 합니다. 개발을 하다보면 코드가 길어지게되고 그만큼 CSS코드도 많아집니다.
또한 스타일지정이 반복되는 경우도 많고 관리하기도 힘들어집니다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 문제들을 해결할 수 있는 CSS Preprocessor(전처리기)라는 것이 있습니다. 그중에 하나가 Sass입니다. 
Sass는 CSS와 동일하게 코드를 작성할 수 있는데 추가적으로 프로그래밍적인 문법이 추가된 것입니다.
예를 들어서 조건문이나 반복문, 변수 같은 것을 쓸 수 있는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;환경세팅&quot;&gt;환경세팅&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
VSCode 기준으로 익스텐션에서 “Live Sass Compiler”를 검색해서 설치해주시면 됩니다.
&lt;img src=&quot;https://user-images.githubusercontent.com/17917009/180705785-224e4ce3-7fb7-486c-9a0c-77c5396612fe.png&quot; alt=&quot;image&quot; /&gt;
&lt;br /&gt;
이후에는 일반 css사용하는 것과 똑같은데 .css확장자가 아니라 .scss라는 확장자로 파일을 만들어서 코드를 작성합니다. 물론 브라우저는 이 css파일만 읽을 수 있습니다. 그래서 scss파일을 css로 바꿔줘야하기 때문에 
“Live Sass Compiler” 익스텐션을 설치한 것입니다. 
&lt;br /&gt;&lt;br /&gt;
참고로 .sass라는 확장자로 파일을 만들 수도 있는데 .sass파일은 css를 작성할 때 중괄호를 쓰지 않는다는 점이 다르고 거의 차이가 없습니다. 개인적으로는 중괄호를 쓰는게 더 편하기 때문에 .scss확장자를 사용하는게 편하다고 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/17917009/180707384-0e50f2eb-8be7-4695-a948-3fc099763a74.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;scss파일에 코드를 작성했다면 vscode 하단에 다음과 같이 “Watch Sass” 버튼을 눌러주시면 됩니다.
그러면 알아서 변환된 css파일이 생성이 될 것이고, 그 변환된 css파일을 가져다 사용하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;sass에서-변수사용하기&quot;&gt;Sass에서 변수사용하기&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-scss highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$big-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$middle-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$small-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$middle-size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 size를 $기호와 함께 변수로 저장해두고 그 값을 가져다 쓸 수 있습니다.
또한 사칙연산도 가능합니다.&lt;/p&gt;

&lt;p&gt;물론 sass를 쓰지 않아도 var()를 사용해서 변수를 만들 수 있고, 사칙연산도 calc()를 사용하면 연산이 가능하지만, 개인적으로는 sass를 쓰는 게 더 편한 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;nesting&quot;&gt;Nesting&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.btn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;border-radius&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;.content 안에 p태그와 “btn” 클래스를 가진 버튼이 있다고 가정해보겠습니다. p와 버튼태그에 접근하려면 위의 코드처럼 접근해야합니다. 위의 코드는 간단한 코드이기 때문에 상관없을 수 있지만, 코드가 길어지면 복잡해보일 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-scss highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.btn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;border-radius&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그래서 sass를 사용해서 네스팅을 할 수 있습니다. 이전 코드보다 눈으로 보기에도 훨씬 좋아졌고 관리하기도 쉬워집니다.&lt;/p&gt;

&lt;h2 id=&quot;extend로-확장하기&quot;&gt;@extend로 확장하기&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-scss highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;%button&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;border-radius&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.yellow-button&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;@extend&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;yellow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.black-button&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;@extend&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;노란색버튼과 검은색버튼을 만들고 싶다고 가정해보면, 중복되는 코드를 “%”를 사용해서 위처럼 임시클래스로 정의해두고 각 버튼에 “@extend”를 사용하여 불러올 수 있습니다. 이렇게 하면 귀찮은 반복을 줄일 수 있는 장점이 있습니다.&lt;br /&gt;
참고로 %를 사용해서 정의한 임시클래스만 정의해놓으면 그 임시클래스는 컴파일되지 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;mixin--include&quot;&gt;@Mixin &amp;amp; @include&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
위의 @extend와 유사하게 사용할 수 있는게 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-scss highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@mixin&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buttonDesign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bgColor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;border-radius&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$bgColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;nc&quot;&gt;.yellow-button&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;@include&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;buttonDesign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;yellow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;// 함수처럼 사용이 가능함&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 인자로 배경색은 노란색, 글자색은 검은색을 줌.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수를 정의하고 호출하듯이 사용할 수 있는 것이 @Mixin 입니다.&lt;br /&gt;
“@extend”에서 만든 것처럼 노란색 버튼을 위처럼 만들 수 있습니다.&lt;br /&gt;
“@mixin”을 붙인후 함수처럼 위와 같이 정의해준 후, 그 함수를 불러오듯이 “@include”로 가져오면 됩니다.
“@extend”와의 차이는 위처럼 매개변수를 넣을 수 있다는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;use&quot;&gt;@use&lt;/h2&gt;

&lt;p&gt;외부 css코드를 가져오고 싶을 때 @use를 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-scss highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@use&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'_init.scss&quot;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적으로 import하는 것과 같다고 볼 수 있습니다. &lt;br /&gt;
“@use”와 함께 경로를 써주면 됩니다. 확장자는 생략가능합니다.&lt;/p&gt;

&lt;p&gt;외부에서 불러온 css파일에서 정의된 변수를 사용하고 싶다면 “파일이름.$변수이름”으로 접근할 수 있습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;추가로, 종속되는 파일과 같이 단독으로는 컴파일할 필요가 없는 파일들은 파일명 앞에 “_“를 붙여서 컴파일을 하지 않도록 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="css" /><summary type="html">CSS는 다음과 같이 구성되어 있습니다. CSS의 의미와 적용방법 block과 inline의 차이점 em과 rem의 차이 Sass - CSS 전처리기</summary></entry><entry><title type="html">라이브러리와 프레임워크</title><link href="https://ykkim97.github.io/etc-libraryandframework" rel="alternate" type="text/html" title="라이브러리와 프레임워크" /><published>2022-07-22T22:20:00+09:00</published><updated>2022-07-22T22:20:00+09:00</updated><id>https://ykkim97.github.io/etc-libraryandframework</id><content type="html" xml:base="https://ykkim97.github.io/etc-libraryandframework">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 라이브러리와 프레임워크에 대해서 간단히 정리해보겠습니다.&lt;br /&gt;
개발을 하다보면 이러한 라이브러리를 가져와서 사용한다, 혹은 OO 프레임워크를 사용한다, 뭐 이런 말들을 자주 들어봤을 것입니다.&lt;/p&gt;

&lt;p&gt;뭔가 비슷한거같은데 차이점이 뭘까요?&lt;/p&gt;

&lt;h2 id=&quot;라이브러리&quot;&gt;라이브러리&lt;/h2&gt;

&lt;p&gt;라이브러리는 단순하게 활용가능한 도구들의 집합이라고 할 수 있습니다. 개발자가 필요할 때 라이브러리를 호출해서 사용합니다. 
개발자가 원할 때 함수나 기능의 모음인 라이브러리를 가져다 쓰는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;프레임워크&quot;&gt;프레임워크&lt;/h2&gt;

&lt;p&gt;프레임워크는 뼈대, 기반구조이며 “소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합”입니다. 뭔가 와닿지는 않을 것입니다. 어떤 완성된 어플리케이션이 아니라 개발자가 이 프레임워크를 가지고 프레임워크만의 규칙에 맞게 코드를 프레임워크안에 짜넣어서 개발한다고 보면 되겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;쉽게 정리하자면, &lt;br /&gt;
필요할 때 개발자가 호출해서 가져다 쓴다면? 👉🏼 라이브러리&lt;br /&gt;
개발자가 프레임워크에 맞춰서 코드를 작성하고 사용한다면? 👉🏼 프레임워크&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry><entry><title type="html">CSR, SSR, SSG의 차이</title><link href="https://ykkim97.github.io/etc-csrssrssg" rel="alternate" type="text/html" title="CSR, SSR, SSG의 차이" /><published>2022-07-21T23:10:00+09:00</published><updated>2022-07-21T23:10:00+09:00</updated><id>https://ykkim97.github.io/etc-csrssrssg</id><content type="html" xml:base="https://ykkim97.github.io/etc-csrssrssg">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 CSR, SSR, SSG 방식의 차이를 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;csr&quot;&gt;CSR&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
CSR(Client-Side-Rendering)은 클라이언트 사이드 렌더링의 약자입니다. 말그대로 클라이언트 쪽에서 렌더링을 하는 것을 말하는 것입니다.&lt;br /&gt;
빈 HTML을 서버로부터 클라이언트가 받게되고, 추가적으로 어플리케이션에서 필요한 자바스크립트파일을 다운받게 됩니다. 이 파일은 어플리케이션에서
필요한 로직들과 어플리케이션을 구동하는 프레임워크와 라이브러리의 소스코드들이 포함되어있습니다. 이것들은 파일사이즈가 커서 다운로드 받는데 시간이
오래걸릴 수 있습니다. 추가로 필요한 데이터가 있으면 서버에 요청해서 데이터를 받아오며, 이것들을 기반으로 동적으로 HTML을 생성하게 됩니다. 
&lt;br /&gt;&lt;br /&gt;
CSR은 필요한 부분만 요청하고 응답하기 때문에 서버의 부하가 적고, 초기 로딩이후 속도가 빠릅니다.  그리고TTV와 TTI의 간극이 없어 페이지가 무응답하지 않고 잘 동작합니다. &lt;br /&gt;&lt;br /&gt;
하지만, 단점도 존재합니다. &lt;br /&gt;
이런 CSR(클라이언트 사이드 렌더링)의 문제점은 뭐가 있을까요?
일단 사용자가 웹사이트의 처음화면을 보기까지 오래걸릴 수 있다는 것이고, 좋지 않은 SEO가 있겠습니다.&lt;br /&gt;
검색엔진들이 서버에 등록된 웹사이트들을 하나하나 분석하여, 검색시에 웹사이트를 빠르게 검색할 수 있도록 도와줍니다. CSR방식의 HTML은 대부분 비어져있기 때문에,
검색엔진들이 사이트를 분석하기 어려워합니다. 구글에서는 개선이 되었다고는 하지만 여전히 SEO가 좋지 못합니다.&lt;/p&gt;

&lt;h2 id=&quot;ssr&quot;&gt;SSR&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
SSR(Server Side Rendering)은 서버 사이드 렌더링의 약자입니다. 서버측에서 렌더링하는 것이겠지요.&lt;br /&gt;
클라이언트의 요청을 받은 즉시, 서버는 화면에 표시하는데 필요한 데이터를 모두 받아와서 HTML을 모두 구성한 다음 브라우저로 전송하는 것입니다.&lt;br /&gt;
브라우저는 받은 페이지를 바로 화면에 보여주게 됩니다.&lt;br /&gt;
&lt;br /&gt;
SSR의 장점은, CSR을 사용했을 때 보다 첫 페이지로딩이 빨라지게 되고, 모든 컨텐츠가 HTML에 담겨져 있기 떄문에 좀 더 효율적인 SEO를 할 수 있습니다.&lt;br /&gt;&lt;br /&gt;
하지만 장점만 있는 것이 아닙니다. 요청시마다 새로고침되기 때문에 깜빡임 이슈가 존재합니다. 또한 TTV와 TTI의 간격이 있다는 것입니다. 페이지는 잘 보일지 몰라도 자바스크립트가
아직 적용되지 않은 시간동안에는 페이지가 반응을 하지 못하는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;ssg&quot;&gt;SSG&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
SSG라는 것도 존재합니다. &lt;br /&gt;
SSG(Static Site Generation)은 자주 업데이트되지 않는 사이트에 좋은데, SSR처럼 서버에서 완성된 HTML을 받아오는 것은 맞지만, HTML 파일의 생성이 빌드타임에서 생성됩니다.&lt;br /&gt;&lt;br /&gt;
그러니까 SSR은 요청이 들어오는 즉시 HTML를 만들어서 응답하고, SSG는 빌드시점에 HTML을 미리 만들어두었다가 요청이 들어오면 만들어둔 완성된 HTML을 보내주는 것에 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry><entry><title type="html">em과 rem의 차이</title><link href="https://ykkim97.github.io/css-emAndRem" rel="alternate" type="text/html" title="em과 rem의 차이" /><published>2022-07-19T23:35:00+09:00</published><updated>2022-07-19T23:35:00+09:00</updated><id>https://ykkim97.github.io/css-emAndRem</id><content type="html" xml:base="https://ykkim97.github.io/css-emAndRem">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;CSS는 다음과 같이 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./css-basic&quot;&gt;CSS의 의미와 적용방법&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-blockinline&quot;&gt;block과 inline의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-emAndRem&quot;&gt;em과 rem의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-sass&quot;&gt;Sass - CSS 전처리기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 css에서 사용되는 em, rem의 차이에 대해서 알아보겠습니다.
기본적으로 폰트 크기나, 마진, 패딩과 같은 크기값을 지정할 때 픽셀(px)값으로 지정할 수 있지만,
em과 rem이라는 것을 사용하는 경우가 종종 있습니다. 이 차이를 정리해보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;rem&quot;&gt;rem&lt;/h1&gt;
&lt;p&gt;rem은 기준이 되는 값의 배수로 변환한 값입니다. 2rem이라면 기준이 되는 값의 2배라는 것이죠.
그러면 기준이 되는 값이 뭘까요? &lt;br /&gt;
바로 최상위요소(보통은 html)에서 지정된 값이 기준이 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 html의 font-size가 14px로 지정되어 있고 p태그의 font-size는 1.5rem으로 지정되어있습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;p의 font-size는 1.5rem이므로 최상위 요소에 지정된 14px의 1.5배 값이 되어 21px이 되는 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;em&quot;&gt;em&lt;/h1&gt;

&lt;p&gt;em도 기준이 되는 값의 배수로 변환한 값인데, 기준이 되는 값이 다릅니다. &lt;br /&gt;
바로 이것은 현재 지정요소의 값이 기준이 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면은 div의 font-size값이 16px로 지정되어있고, 바로 밑에 1.5rem 값이 지정되어있습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그러면 16 * 1.5인 24px이 적용이 되는 것이죠.&lt;/p&gt;

&lt;p&gt;만약에 지정된 기준값이 없다면 어떻게 될까요?
&lt;br /&gt;&lt;br /&gt;
해당요소는 부모요소의 지정된 값을 상속받습니다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;content의 font-size는 2em 이니까, 10px * 2 * 2 = 40px이 되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="css" /><summary type="html">CSS는 다음과 같이 구성되어 있습니다. CSS의 의미와 적용방법 block과 inline의 차이점 em과 rem의 차이 Sass - CSS 전처리기</summary></entry><entry><title type="html">git add , commit, 그리고 staging</title><link href="https://ykkim97.github.io/git-gitaddcommit" rel="alternate" type="text/html" title="git add , commit, 그리고 staging" /><published>2022-07-17T03:32:00+09:00</published><updated>2022-07-17T03:32:00+09:00</updated><id>https://ykkim97.github.io/git-gitaddcommit</id><content type="html" xml:base="https://ykkim97.github.io/git-gitaddcommit">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Git은 다음과 같이 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./git-githubissuelabel&quot;&gt;Github Label별 의미&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./git-gitaddcommit&quot;&gt;git add , commit, 그리고 staging&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./git-gitflow&quot;&gt;Git Flow 전략에 대해(브랜치 관리 전략)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
git은 변경사항을 추적하고 여러 명의 사용자들 간에 파일의 작업을 조율하기 위한 “버전 관리”소프트웨어 입니다.
오늘은 git 명령중에 git add, commit 명령에 대해서 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;git-add--commit-그리고-staging&quot;&gt;git add , commit, 그리고 staging&lt;/h2&gt;

&lt;p&gt;작업폴더에 “test.txt”라는 파일을 생성해서 작성했다고 가정해보겠습니다.
이때 “test.txt”파일을 기록하고 싶습니다. 일단, “git add test.txt”라는 명령을 터미널에 입력해주면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;git add test.txt
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;말 그대로 추가하는 겁니다. 그런데, 어디에 추가하는 걸까요? 바로 리포지토리에 추가가 되는 걸까요?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
“git add 파일명”이라는 명령은 일단은 Staging Area라는 곳에 파일을 넣어둡니다. &lt;br /&gt;
Staging Area는 커밋하기전에 커밋할 파일을 골라놓는 곳이고 이런 행위를 스테이징한다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
이제 여기서 커밋명령을 해주어야합니다.
커밋을 해주면 repository에 기록됩니다. 파일 버전을 모아둔다고 말을 합니다.
아 물론, 작업폴더안의 전체 파일을 기록하고싶다면 “git add .”을 입력하면됩니다.&lt;/p&gt;

&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;git add .
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
커밋을 하는 방법은 ‘ git commit -m “쓰고싶은 메세지” ‘를 터미널에 입력해주는 것입니다. 메세지는 현재 커밋하는 내용이 어떤 내용인지 알 수 있게 적어주면됩니다.&lt;/p&gt;

&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;git commit -m &quot;테스트용 파일 추가&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
정리해보면 커밋하기전에 커밋할 파일을 골라놓는 곳인 “Staging Area”에 “git add”를 통해 파일을 넣어주고, 커밋된 파일버전을 모아놓는 곳인 “repository”에 
“git commit”을 통해 커밋합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="git" /><summary type="html">Git은 다음과 같이 구성되어 있습니다. Github Label별 의미 git add , commit, 그리고 staging Git Flow 전략에 대해(브랜치 관리 전략)</summary></entry><entry><title type="html">AJAX가 무엇일까?</title><link href="https://ykkim97.github.io/javascript-aboutajax" rel="alternate" type="text/html" title="AJAX가 무엇일까?" /><published>2022-07-14T04:45:00+09:00</published><updated>2022-07-14T04:45:00+09:00</updated><id>https://ykkim97.github.io/javascript-aboutajax</id><content type="html" xml:base="https://ykkim97.github.io/javascript-aboutajax">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;JavaScript 관련 글입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-eventloop&quot;&gt;JS Event Loop, 자바스크립트 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-hoisting&quot;&gt;호이스팅이란 , var, let, const 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-AboutThreejs&quot;&gt;Three.js에 대해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-scripttag&quot;&gt;script, script async, script defer의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-aboutajax&quot;&gt;AJAX가 무엇일까?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-functionExpression&quot;&gt;함수선언식과 함수표현식&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 AJAX에 대해서 간단히 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;ajax&quot;&gt;AJAX?&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
AJAX는 “Asynchronous Javascript And XML” 의 약자로 서버와 비동기적으로 데이터를 주고 받는 자바스크립트 기술입니다. 
AJAX는 웹페이지 전체를 새로고침하지 않아도 페이지의 일부만 갱신할 수 있습니다.
&lt;br /&gt;
&lt;br /&gt;
이전에는 웹페이지의 작은 일부가 변해도 새로운 페이지 전체를 다시 로드해야했습니다. 그래서 화면이 깜빡이는 현상이 있었고, 이것은 시간적으로나 자원적으로나 낭비입니다.
하지만 AJAX를 이용하면 페이지 전체가 아니라, 일부분만 갱신할 수 있습니다. 따라서 깜빡임 현상도 일어나지않고 새로고침없이 화면이 부드럽게 전환됩니다.&lt;/p&gt;

&lt;h2 id=&quot;ajax의-장단점&quot;&gt;AJAX의 장단점&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;장점&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;웹페이지의 전체를 재로딩하지 않아도, 일부분만 갱신가능하다.&lt;/li&gt;
  &lt;li&gt;불필요한 데이터 요청을 최소화할 수 있고 많은 일이 클라이언트 웹 브라우저에서 처리가능&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;단점&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;보안에 주의해야한다.&lt;/li&gt;
  &lt;li&gt;연속해서 데이터를 요청을 남발하면 서버 부하가 생길 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이외에도 장단점이 있겠지만 크게는 이렇습니다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용법&quot;&gt;사용법&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
사용법은 여러 방법이 있는데 간단히 정리해보자면 다음과 같습니다. (전통적인 방법은 제외)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;fetch함수 사용&lt;/li&gt;
  &lt;li&gt;jQuery의 ajax()함수 사용&lt;/li&gt;
  &lt;li&gt;리액트나 뷰와 같은 환경에서는 axios 라이브러리 설치하여 사용&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="javascript" /><summary type="html">JavaScript 관련 글입니다. JS Event Loop, 자바스크립트 동작 원리 호이스팅이란 , var, let, const 차이 Three.js에 대해 script, script async, script defer의 차이 AJAX가 무엇일까? 함수선언식과 함수표현식</summary></entry><entry><title type="html">script, script async, script defer의 차이</title><link href="https://ykkim97.github.io/javascript-scripttag" rel="alternate" type="text/html" title="script, script async, script defer의 차이" /><published>2022-07-13T06:45:00+09:00</published><updated>2022-07-13T06:45:00+09:00</updated><id>https://ykkim97.github.io/javascript-scripttag</id><content type="html" xml:base="https://ykkim97.github.io/javascript-scripttag">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;JavaScript 관련 글입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-eventloop&quot;&gt;JS Event Loop, 자바스크립트 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-hoisting&quot;&gt;호이스팅이란 , var, let, const 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-AboutThreejs&quot;&gt;Three.js에 대해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-scripttag&quot;&gt;script, script async, script defer의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-aboutajax&quot;&gt;AJAX가 무엇일까?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-functionExpression&quot;&gt;함수선언식과 함수표현식&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 script 태그에 대해서 알아보겠습니다.
script태그는 자바스크립트를 정의할 때 사용합니다. 문서파일에 자바스크립트를 추가하는 방법이 3가지가 있는데, 각각 특징이 다릅니다.
이것에 대해서 정리해 보도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;script-script-async-script-defer-의-차이&quot;&gt;script, script async, script defer 의 차이&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;script
&lt;br /&gt;
그냥 일반적인 방법입니다. HTML을 파싱하는 중에 이 script태그를 만나면 HTML파싱을 중지하고 스크립트를 다운받아 파싱하고 실행합니다.
이것이 완료되면 다시 HTML을 파싱합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script async
&lt;br /&gt;
async 속성이 붙은 경우입니다. 이것은 HTML파싱을 하면서 script태그를 만나면 문서를 파싱하면서 스크립트를 다운받습니다. 
다운이 완료되는 즉시 HTML 파싱을 멈추고 스크립트를 실행합니다. 실행이 끝나면 남은 HTML 문서를 분석합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script defer
&lt;br /&gt;
defer 속성이 붙은 경우는 async 처럼 script태그를 만났을 때 스크립트를 다운받는데, HTML파싱이 모두 완료되면 받아놓은 자바스크립트를 실행하게 됩니다.
HTML을 파싱하는 동안 필요한 자바스크립트파일을 받아놓고 HTML을 모두 파싱해서 사용자에게 페이지를 먼저 보여준 후 바로 이어서 자바스크립트를 실행합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;script 태그 : HTML 파싱중에 script 태그 만남 -&amp;gt; HTML파싱을 중지하고 스크립트 다운,파싱,실행 -&amp;gt; 끝나면 다시 HTML파싱&lt;/li&gt;
  &lt;li&gt;script async 태그 : HTML 파싱중에 script 태그 만남 -&amp;gt; 아직 HTML 파싱을 중지시키지 않고 스크립트 다운 -&amp;gt; 다운완료되면 그때서야 HTML파싱 중지 후 스크립트 실행 -&amp;gt; 끝나면 다시 HTML파싱&lt;/li&gt;
  &lt;li&gt;script defer 태그 : HTML 파싱중에 script 태그 만남  -&amp;gt; HTML파싱을 중지시키지 않고 스크립트를 다운받음 -&amp;gt; 다운완료되어도 HTML파싱을 모두 완료한 후에야 스크립트를 실행함.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="javascript" /><summary type="html">JavaScript 관련 글입니다. JS Event Loop, 자바스크립트 동작 원리 호이스팅이란 , var, let, const 차이 Three.js에 대해 script, script async, script defer의 차이 AJAX가 무엇일까? 함수선언식과 함수표현식</summary></entry><entry><title type="html">프로세스와 쓰레드의 차이점</title><link href="https://ykkim97.github.io/etc-processandthread" rel="alternate" type="text/html" title="프로세스와 쓰레드의 차이점" /><published>2022-07-12T07:20:00+09:00</published><updated>2022-07-12T07:20:00+09:00</updated><id>https://ykkim97.github.io/etc-processandthread</id><content type="html" xml:base="https://ykkim97.github.io/etc-processandthread">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 프로세스와 쓰레드에 대해서 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;프로세스-쓰레드&quot;&gt;프로세스? 쓰레드?&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
프로세스는 한마디로 실행중인 프로그램이라고 할 수 있습니다. &lt;br /&gt;
여기서또 프로그램과 프로세스를 혼동할 수 있는데 프로그램은 실행가능한 명령어들의 집합입니다.
&lt;br /&gt;
&lt;br /&gt;
그러면 쓰레드는 뭘까요?
&lt;br /&gt;
그 프로세스 내에서 동작되는 여러 실행의 흐름입니다.&lt;/p&gt;

&lt;h2 id=&quot;둘의-차이점&quot;&gt;둘의 차이점&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
프로세스는 최소 하나의 쓰레드를 보유하고 있고 각각 별도의 주소공간을 할당받습니다. 독립적이죠.
그런데 쓰레드는 Stack을 제외하고 Code, Data, Heap의 나머지 영역을 서로 공유합니다.&lt;/p&gt;

&lt;h2 id=&quot;프로세스-메모리-영역&quot;&gt;프로세스 메모리 영역&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
잠깐 프로세스 메모리 영역에 대해서 알아보겠습니다.
&lt;br /&gt;&lt;br /&gt;
커널 메모리 안에서 관리되는 PCB(Process Control Block) 정보외에 유저가 사용하는 메모리안의 프로세스 정보는 4가지가 있는데, Code, Data, Heap, Stack이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Code: 프로그램의 실제 코드 저장&lt;/li&gt;
  &lt;li&gt;Data: 프로세스가 실행될 때 정의된 전역 변수. Static 변수들을 저장&lt;/li&gt;
  &lt;li&gt;Heap: 프로세스 런타임 중 동적할당 변수들을 저장&lt;/li&gt;
  &lt;li&gt;Stack: 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간이고 함수 호출 시에 기록하고 끝나면 사라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;멀티프로세스-vs-멀티쓰레드&quot;&gt;멀티프로세스 vs 멀티쓰레드&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
멀티프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하여 각각의 프로세스가 하나의 작업을 처리하는 것이고 멀티쓰레드는, 하나의 프로그램을 여러개의 쓰레드로 구성하고 각 쓰레드가 하나의 작업을 처리하는 것입니다. 자세한 차이점은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;멀티프로세스는 각 프로세스가 독립적이고 쓰레드는 서로 긴밀하게 연결되어있습니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 IPC를 사용한 통신을 해야하는데, 쓰레드는 공유된 자원으로 통신비용이 절감됩니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 개별 메모리를 차지하는데 쓰레드는 자원을 공유하기 때문에 좀더 효율적입니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 Context Switching 비용이 멀티쓰레드보다 비효율적입니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 동기화작업이 필요하지 않고, 멀티쓰레드는 공유자원을 관리해야 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry></feed>