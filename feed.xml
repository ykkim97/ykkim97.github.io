<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://ykkim97.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ykkim97.github.io/" rel="alternate" type="text/html" /><updated>2022-07-23T22:00:36+09:00</updated><id>https://ykkim97.github.io/feed.xml</id><title type="html">YoungGwon’s IT Tech Blog</title><subtitle>IT 기술 블로그입니다.</subtitle><entry><title type="html">라이브러리와 프레임워크</title><link href="https://ykkim97.github.io/etc-libraryandframework" rel="alternate" type="text/html" title="라이브러리와 프레임워크" /><published>2022-07-22T22:20:00+09:00</published><updated>2022-07-22T22:20:00+09:00</updated><id>https://ykkim97.github.io/etc-libraryandframework</id><content type="html" xml:base="https://ykkim97.github.io/etc-libraryandframework">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 라이브러리와 프레임워크에 대해서 간단히 정리해보겠습니다.&lt;br /&gt;
개발을 하다보면 이러한 라이브러리를 가져와서 사용한다, 혹은 OO 프레임워크를 사용한다, 뭐 이런 말들을 자주 들어봤을 것입니다.&lt;/p&gt;

&lt;p&gt;뭔가 비슷한거같은데 차이점이 뭘까요?&lt;/p&gt;

&lt;h2 id=&quot;라이브러리&quot;&gt;라이브러리&lt;/h2&gt;

&lt;p&gt;라이브러리는 단순하게 활용가능한 도구들의 집합이라고 할 수 있습니다. 개발자가 필요할 때 라이브러리를 호출해서 사용합니다. 
개발자가 원할 때 함수나 기능의 모음인 라이브러리를 가져다 쓰는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;프레임워크&quot;&gt;프레임워크&lt;/h2&gt;

&lt;p&gt;프레임워크는 뼈대, 기반구조이며 “소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합”입니다. 뭔가 와닿지는 않을 것입니다. 어떤 완성된 어플리케이션이 아니라 개발자가 이 프레임워크를 가지고 프레임워크만의 규칙에 맞게 코드를 프레임워크안에 짜넣어서 개발한다고 보면 되겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;쉽게 정리하자면, &lt;br /&gt;
필요할 때 개발자가 호출해서 가져다 쓴다면? 👉🏼 라이브러리&lt;br /&gt;
개발자가 프레임워크에 맞춰서 코드를 작성하고 사용한다면? 👉🏼 프레임워크&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry><entry><title type="html">CSR, SSR, SSG의 차이</title><link href="https://ykkim97.github.io/etc-csrssrssg" rel="alternate" type="text/html" title="CSR, SSR, SSG의 차이" /><published>2022-07-21T23:10:00+09:00</published><updated>2022-07-21T23:10:00+09:00</updated><id>https://ykkim97.github.io/etc-csrssrssg</id><content type="html" xml:base="https://ykkim97.github.io/etc-csrssrssg">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 CSR, SSR, SSG 방식의 차이를 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;csr&quot;&gt;CSR&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
CSR(Client-Side-Rendering)은 클라이언트 사이드 렌더링의 약자입니다. 말그대로 클라이언트 쪽에서 렌더링을 하는 것을 말하는 것입니다.&lt;br /&gt;
빈 HTML을 서버로부터 클라이언트가 받게되고, 추가적으로 어플리케이션에서 필요한 자바스크립트파일을 다운받게 됩니다. 이 파일은 어플리케이션에서
필요한 로직들과 어플리케이션을 구동하는 프레임워크와 라이브러리의 소스코드들이 포함되어있습니다. 이것들은 파일사이즈가 커서 다운로드 받는데 시간이
오래걸릴 수 있습니다. 추가로 필요한 데이터가 있으면 서버에 요청해서 데이터를 받아오며, 이것들을 기반으로 동적으로 HTML을 생성하게 됩니다. 
&lt;br /&gt;&lt;br /&gt;
CSR은 필요한 부분만 요청하고 응답하기 때문에 서버의 부하가 적고, 초기 로딩이후 속도가 빠릅니다.  그리고TTV와 TTI의 간극이 없어 페이지가 무응답하지 않고 잘 동작합니다. &lt;br /&gt;&lt;br /&gt;
하지만, 단점도 존재합니다. &lt;br /&gt;
이런 CSR(클라이언트 사이드 렌더링)의 문제점은 뭐가 있을까요?
일단 사용자가 웹사이트의 처음화면을 보기까지 오래걸릴 수 있다는 것이고, 좋지 않은 SEO가 있겠습니다.&lt;br /&gt;
검색엔진들이 서버에 등록된 웹사이트들을 하나하나 분석하여, 검색시에 웹사이트를 빠르게 검색할 수 있도록 도와줍니다. CSR방식의 HTML은 대부분 비어져있기 때문에,
검색엔진들이 사이트를 분석하기 어려워합니다. 구글에서는 개선이 되었다고는 하지만 여전히 SEO가 좋지 못합니다.&lt;/p&gt;

&lt;h2 id=&quot;ssr&quot;&gt;SSR&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
SSR(Server Side Rendering)은 서버 사이드 렌더링의 약자입니다. 서버측에서 렌더링하는 것이겠지요.&lt;br /&gt;
클라이언트의 요청을 받은 즉시, 서버는 화면에 표시하는데 필요한 데이터를 모두 받아와서 HTML을 모두 구성한 다음 브라우저로 전송하는 것입니다.&lt;br /&gt;
브라우저는 받은 페이지를 바로 화면에 보여주게 됩니다.&lt;br /&gt;
&lt;br /&gt;
SSR의 장점은, CSR을 사용했을 때 보다 첫 페이지로딩이 빨라지게 되고, 모든 컨텐츠가 HTML에 담겨져 있기 떄문에 좀 더 효율적인 SEO를 할 수 있습니다.&lt;br /&gt;&lt;br /&gt;
하지만 장점만 있는 것이 아닙니다. 요청시마다 새로고침되기 때문에 깜빡임 이슈가 존재합니다. 또한 TTV와 TTI의 간격이 있다는 것입니다. 페이지는 잘 보일지 몰라도 자바스크립트가
아직 적용되지 않은 시간동안에는 페이지가 반응을 하지 못하는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;ssg&quot;&gt;SSG&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
SSG라는 것도 존재합니다. &lt;br /&gt;
SSG(Static Site Generation)은 자주 업데이트되지 않는 사이트에 좋은데, SSR처럼 서버에서 완성된 HTML을 받아오는 것은 맞지만, HTML 파일의 생성이 빌드타임에서 생성됩니다.&lt;br /&gt;&lt;br /&gt;
그러니까 SSR은 요청이 들어오는 즉시 HTML를 만들어서 응답하고, SSG는 빌드시점에 HTML을 미리 만들어두었다가 요청이 들어오면 만들어둔 완성된 HTML을 보내주는 것에 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry><entry><title type="html">em과 rem의 차이</title><link href="https://ykkim97.github.io/css-emAndRem" rel="alternate" type="text/html" title="em과 rem의 차이" /><published>2022-07-19T23:35:00+09:00</published><updated>2022-07-19T23:35:00+09:00</updated><id>https://ykkim97.github.io/css-emAndRem</id><content type="html" xml:base="https://ykkim97.github.io/css-emAndRem">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;CSS는 다음과 같이 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./css-basic&quot;&gt;CSS의 의미와 적용방법&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-blockinline&quot;&gt;block과 inline의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./css-emAndRem&quot;&gt;em과 rem의 차이&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 css에서 사용되는 em, rem의 차이에 대해서 알아보겠습니다.
기본적으로 폰트 크기나, 마진, 패딩과 같은 크기값을 지정할 때 픽셀(px)값으로 지정할 수 있지만,
em과 rem이라는 것을 사용하는 경우가 종종 있습니다. 이 차이를 정리해보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;rem&quot;&gt;rem&lt;/h1&gt;
&lt;p&gt;rem은 기준이 되는 값의 배수로 변환한 값입니다. 2rem이라면 기준이 되는 값의 2배라는 것이죠.
그러면 기준이 되는 값이 뭘까요? &lt;br /&gt;
바로 최상위요소(보통은 html)에서 지정된 값이 기준이 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면 html의 font-size가 14px로 지정되어 있고 p태그의 font-size는 1.5rem으로 지정되어있습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;p의 font-size는 1.5rem이므로 최상위 요소에 지정된 14px의 1.5배 값이 되어 21px이 되는 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;em&quot;&gt;em&lt;/h1&gt;

&lt;p&gt;em도 기준이 되는 값의 배수로 변환한 값인데, 기준이 되는 값이 다릅니다. &lt;br /&gt;
바로 이것은 현재 지정요소의 값이 기준이 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시를 보면은 div의 font-size값이 16px로 지정되어있고, 바로 밑에 1.5rem 값이 지정되어있습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그러면 16 * 1.5인 24px이 적용이 되는 것이죠.&lt;/p&gt;

&lt;p&gt;만약에 지정된 기준값이 없다면 어떻게 될까요?
&lt;br /&gt;&lt;br /&gt;
해당요소는 부모요소의 지정된 값을 상속받습니다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;content의 font-size는 2em 이니까, 10px * 2 * 2 = 40px이 되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="css" /><summary type="html">CSS는 다음과 같이 구성되어 있습니다. CSS의 의미와 적용방법 block과 inline의 차이점 em과 rem의 차이</summary></entry><entry><title type="html">git add , commit, 그리고 staging</title><link href="https://ykkim97.github.io/git-gitaddcommit" rel="alternate" type="text/html" title="git add , commit, 그리고 staging" /><published>2022-07-17T03:32:00+09:00</published><updated>2022-07-17T03:32:00+09:00</updated><id>https://ykkim97.github.io/git-gitaddcommit</id><content type="html" xml:base="https://ykkim97.github.io/git-gitaddcommit">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Git은 다음과 같이 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./git-githubissuelabel&quot;&gt;Github Label별 의미&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./git-gitaddcommit&quot;&gt;git add , commit, 그리고 staging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
git은 변경사항을 추적하고 여러 명의 사용자들 간에 파일의 작업을 조율하기 위한 “버전 관리”소프트웨어 입니다.
오늘은 git 명령중에 git add, commit 명령에 대해서 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;git-add--commit-그리고-staging&quot;&gt;git add , commit, 그리고 staging&lt;/h2&gt;

&lt;p&gt;작업폴더에 “test.txt”라는 파일을 생성해서 작성했다고 가정해보겠습니다.
이때 “test.txt”파일을 기록하고 싶습니다. 일단, “git add test.txt”라는 명령을 터미널에 입력해주면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;git add test.txt
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;말 그대로 추가하는 겁니다. 그런데, 어디에 추가하는 걸까요? 바로 리포지토리에 추가가 되는 걸까요?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
“git add 파일명”이라는 명령은 일단은 Staging Area라는 곳에 파일을 넣어둡니다. &lt;br /&gt;
Staging Area는 커밋하기전에 커밋할 파일을 골라놓는 곳이고 이런 행위를 스테이징한다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
이제 여기서 커밋명령을 해주어야합니다.
커밋을 해주면 repository에 기록됩니다. 파일 버전을 모아둔다고 말을 합니다.
아 물론, 작업폴더안의 전체 파일을 기록하고싶다면 “git add .”을 입력하면됩니다.&lt;/p&gt;

&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;git add .
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
커밋을 하는 방법은 ‘ git commit -m “쓰고싶은 메세지” ‘를 터미널에 입력해주는 것입니다. 메세지는 현재 커밋하는 내용이 어떤 내용인지 알 수 있게 적어주면됩니다.&lt;/p&gt;

&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;git commit -m &quot;테스트용 파일 추가&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
정리해보면 커밋하기전에 커밋할 파일을 골라놓는 곳인 “Staging Area”에 “git add”를 통해 파일을 넣어주고, 커밋된 파일버전을 모아놓는 곳인 “repository”에 
“git commit”을 통해 커밋합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="git" /><summary type="html">Git은 다음과 같이 구성되어 있습니다. Github Label별 의미 git add , commit, 그리고 staging</summary></entry><entry><title type="html">AJAX가 무엇일까?</title><link href="https://ykkim97.github.io/javascript-aboutajax" rel="alternate" type="text/html" title="AJAX가 무엇일까?" /><published>2022-07-14T04:45:00+09:00</published><updated>2022-07-14T04:45:00+09:00</updated><id>https://ykkim97.github.io/javascript-aboutajax</id><content type="html" xml:base="https://ykkim97.github.io/javascript-aboutajax">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;JavaScript 관련 글입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-eventloop&quot;&gt;JS Event Loop, 자바스크립트 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-hoisting&quot;&gt;호이스팅이란 , var, let, const 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-AboutThreejs&quot;&gt;Three.js에 대해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-scripttag&quot;&gt;script, script async, script defer의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-aboutajax&quot;&gt;AJAX가 무엇일까?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 AJAX에 대해서 간단히 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;ajax&quot;&gt;AJAX?&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
AJAX는 “Asynchronous Javascript And XML” 의 약자로 서버와 비동기적으로 데이터를 주고 받는 자바스크립트 기술입니다. 
AJAX는 웹페이지 전체를 새로고침하지 않아도 페이지의 일부만 갱신할 수 있습니다.
&lt;br /&gt;
&lt;br /&gt;
이전에는 웹페이지의 작은 일부가 변해도 새로운 페이지 전체를 다시 로드해야했습니다. 그래서 화면이 깜빡이는 현상이 있었고, 이것은 시간적으로나 자원적으로나 낭비입니다.
하지만 AJAX를 이용하면 페이지 전체가 아니라, 일부분만 갱신할 수 있습니다. 따라서 깜빡임 현상도 일어나지않고 새로고침없이 화면이 부드럽게 전환됩니다.&lt;/p&gt;

&lt;h2 id=&quot;ajax의-장단점&quot;&gt;AJAX의 장단점&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;장점&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;웹페이지의 전체를 재로딩하지 않아도, 일부분만 갱신가능하다.&lt;/li&gt;
  &lt;li&gt;불필요한 데이터 요청을 최소화할 수 있고 많은 일이 클라이언트 웹 브라우저에서 처리가능&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;단점&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;보안에 주의해야한다.&lt;/li&gt;
  &lt;li&gt;연속해서 데이터를 요청을 남발하면 서버 부하가 생길 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이외에도 장단점이 있겠지만 크게는 이렇습니다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용법&quot;&gt;사용법&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
사용법은 여러 방법이 있는데 간단히 정리해보자면 다음과 같습니다. (전통적인 방법은 제외)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;fetch함수 사용&lt;/li&gt;
  &lt;li&gt;jQuery의 ajax()함수 사용&lt;/li&gt;
  &lt;li&gt;리액트나 뷰와 같은 환경에서는 axios 라이브러리 설치하여 사용&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="javascript" /><summary type="html">JavaScript 관련 글입니다. JS Event Loop, 자바스크립트 동작 원리 호이스팅이란 , var, let, const 차이 Three.js에 대해 script, script async, script defer의 차이 AJAX가 무엇일까?</summary></entry><entry><title type="html">script, script async, script defer의 차이</title><link href="https://ykkim97.github.io/javascript-scripttag" rel="alternate" type="text/html" title="script, script async, script defer의 차이" /><published>2022-07-13T06:45:00+09:00</published><updated>2022-07-13T06:45:00+09:00</updated><id>https://ykkim97.github.io/javascript-scripttag</id><content type="html" xml:base="https://ykkim97.github.io/javascript-scripttag">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;JavaScript 관련 글입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-eventloop&quot;&gt;JS Event Loop, 자바스크립트 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-hoisting&quot;&gt;호이스팅이란 , var, let, const 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-AboutThreejs&quot;&gt;Three.js에 대해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-scripttag&quot;&gt;script, script async, script defer의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./javascript-aboutajax&quot;&gt;AJAX가 무엇일까?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 script 태그에 대해서 알아보겠습니다.
script태그는 자바스크립트를 정의할 때 사용합니다. 문서파일에 자바스크립트를 추가하는 방법이 3가지가 있는데, 각각 특징이 다릅니다.
이것에 대해서 정리해 보도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;script-script-async-script-defer-의-차이&quot;&gt;script, script async, script defer 의 차이&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;script
&lt;br /&gt;
그냥 일반적인 방법입니다. HTML을 파싱하는 중에 이 script태그를 만나면 HTML파싱을 중지하고 스크립트를 다운받아 파싱하고 실행합니다.
이것이 완료되면 다시 HTML을 파싱합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script async
&lt;br /&gt;
async 속성이 붙은 경우입니다. 이것은 HTML파싱을 하면서 script태그를 만나면 문서를 파싱하면서 스크립트를 다운받습니다. 
다운이 완료되는 즉시 HTML 파싱을 멈추고 스크립트를 실행합니다. 실행이 끝나면 남은 HTML 문서를 분석합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script defer
&lt;br /&gt;
defer 속성이 붙은 경우는 async 처럼 script태그를 만났을 때 스크립트를 다운받는데, HTML파싱이 모두 완료되면 받아놓은 자바스크립트를 실행하게 됩니다.
HTML을 파싱하는 동안 필요한 자바스크립트파일을 받아놓고 HTML을 모두 파싱해서 사용자에게 페이지를 먼저 보여준 후 바로 이어서 자바스크립트를 실행합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;script 태그 : HTML 파싱중에 script 태그 만남 -&amp;gt; HTML파싱을 중지하고 스크립트 다운,파싱,실행 -&amp;gt; 끝나면 다시 HTML파싱&lt;/li&gt;
  &lt;li&gt;script async 태그 : HTML 파싱중에 script 태그 만남 -&amp;gt; 아직 HTML 파싱을 중지시키지 않고 스크립트 다운 -&amp;gt; 다운완료되면 그때서야 HTML파싱 중지 후 스크립트 실행 -&amp;gt; 끝나면 다시 HTML파싱&lt;/li&gt;
  &lt;li&gt;script defer 태그 : HTML 파싱중에 script 태그 만남  -&amp;gt; HTML파싱을 중지시키지 않고 스크립트를 다운받음 -&amp;gt; 다운완료되어도 HTML파싱을 모두 완료한 후에야 스크립트를 실행함.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="javascript" /><summary type="html">JavaScript 관련 글입니다. JS Event Loop, 자바스크립트 동작 원리 호이스팅이란 , var, let, const 차이 Three.js에 대해 script, script async, script defer의 차이 AJAX가 무엇일까?</summary></entry><entry><title type="html">프로세스와 쓰레드의 차이점</title><link href="https://ykkim97.github.io/etc-processandthread" rel="alternate" type="text/html" title="프로세스와 쓰레드의 차이점" /><published>2022-07-12T07:20:00+09:00</published><updated>2022-07-12T07:20:00+09:00</updated><id>https://ykkim97.github.io/etc-processandthread</id><content type="html" xml:base="https://ykkim97.github.io/etc-processandthread">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 프로세스와 쓰레드에 대해서 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;프로세스-쓰레드&quot;&gt;프로세스? 쓰레드?&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
프로세스는 한마디로 실행중인 프로그램이라고 할 수 있습니다. &lt;br /&gt;
여기서또 프로그램과 프로세스를 혼동할 수 있는데 프로그램은 실행가능한 명령어들의 집합입니다.
&lt;br /&gt;
&lt;br /&gt;
그러면 쓰레드는 뭘까요?
&lt;br /&gt;
그 프로세스 내에서 동작되는 여러 실행의 흐름입니다.&lt;/p&gt;

&lt;h2 id=&quot;둘의-차이점&quot;&gt;둘의 차이점&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
프로세스는 최소 하나의 쓰레드를 보유하고 있고 각각 별도의 주소공간을 할당받습니다. 독립적이죠.
그런데 쓰레드는 Stack을 제외하고 Code, Data, Heap의 나머지 영역을 서로 공유합니다.&lt;/p&gt;

&lt;h2 id=&quot;프로세스-메모리-영역&quot;&gt;프로세스 메모리 영역&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
잠깐 프로세스 메모리 영역에 대해서 알아보겠습니다.
&lt;br /&gt;&lt;br /&gt;
커널 메모리 안에서 관리되는 PCB(Process Control Block) 정보외에 유저가 사용하는 메모리안의 프로세스 정보는 4가지가 있는데, Code, Data, Heap, Stack이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Code: 프로그램의 실제 코드 저장&lt;/li&gt;
  &lt;li&gt;Data: 프로세스가 실행될 때 정의된 전역 변수. Static 변수들을 저장&lt;/li&gt;
  &lt;li&gt;Heap: 프로세스 런타임 중 동적할당 변수들을 저장&lt;/li&gt;
  &lt;li&gt;Stack: 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간이고 함수 호출 시에 기록하고 끝나면 사라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;멀티프로세스-vs-멀티쓰레드&quot;&gt;멀티프로세스 vs 멀티쓰레드&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
멀티프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하여 각각의 프로세스가 하나의 작업을 처리하는 것이고 멀티쓰레드는, 하나의 프로그램을 여러개의 쓰레드로 구성하고 각 쓰레드가 하나의 작업을 처리하는 것입니다. 자세한 차이점은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;멀티프로세스는 각 프로세스가 독립적이고 쓰레드는 서로 긴밀하게 연결되어있습니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 IPC를 사용한 통신을 해야하는데, 쓰레드는 공유된 자원으로 통신비용이 절감됩니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 개별 메모리를 차지하는데 쓰레드는 자원을 공유하기 때문에 좀더 효율적입니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 Context Switching 비용이 멀티쓰레드보다 비효율적입니다.&lt;/li&gt;
  &lt;li&gt;멀티프로세스는 동기화작업이 필요하지 않고, 멀티쓰레드는 공유자원을 관리해야 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry><entry><title type="html">번들링이 뭔데?</title><link href="https://ykkim97.github.io/etc-whatisbundle" rel="alternate" type="text/html" title="번들링이 뭔데?" /><published>2022-07-10T07:20:00+09:00</published><updated>2022-07-10T07:20:00+09:00</updated><id>https://ykkim97.github.io/etc-whatisbundle</id><content type="html" xml:base="https://ykkim97.github.io/etc-whatisbundle">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 번들링이 무엇인지, 번들링을 하는 이유가 뭔지 간단히 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;번들링에-대해&quot;&gt;번들링에 대해&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
우리가 웹사이트를 만들다보면 자바스크립트, CSS, 이미지와 같은 정말 많은 파일들이 생겨나게 됩니다.
그래서 웹사이트를 로딩해보면 그 수많은 파일들이 다운로드되는 것을 확인할 수 있는데, 이는 서버와의 접속이 많아지게 되고 어플리케이션이 느려지게 됩니다. 
&lt;br /&gt;
또한 여러 많은 JS패키지를 사용하다보면 각각의 패키지들이 서로 같은 변수명, 함수명을 사용하여 예상치 못한 충돌이 발생할 수도 있습니다.
&lt;br /&gt;
&lt;br /&gt;
이러한 문제를 해결할 수 있는 것이 “번들러”입니다. 어플리케이션을 구성하는 여러 파일들을 하나의 파일로 병합해주는 과정을 번들링이라고 하고 그걸을 하는 것이 번들러입니다.
대표적으로 Webpack이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;번들링의-장점&quot;&gt;번들링의 장점&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;번들링하지 않은 경우는 각 파일마다 서버에 요청해서 자원을 얻어와야했는데, 번들링하면 하나의 파일로 만들어지기 때문에 페이지 로딩이 빨라지고 네트워크 접속의 부담을 줄일 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Webpack에서는 로더(Loader)를 통해 바벨이라는 ES6+ 문법을 ES5로 변환할 수 있도록하는 트랜스파일러를 사용할 수 있습니다. 오래된 브라우저에서도 동작할 수 있도록 해주는 장점이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;번들러는 자바스크립트 파일을 기능 단위로 모듈화 하고 이것을 묶어 관리할 수 있게 합니다. 번들러를 사용함으로써 소스 코드를 모듈별로 작성할 수 있고 모듈간 혹은 외부 라이브러리의 의존성을 쉽게 관리 할 수 있습니다.
&lt;br /&gt;
&lt;br /&gt;
이외에도 많은 장점이 있을 수 있지만 3가지 정도만 정리해봤습니다.
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry><entry><title type="html">이벤트 버블링과 캡처링</title><link href="https://ykkim97.github.io/etc-bubbling" rel="alternate" type="text/html" title="이벤트 버블링과 캡처링" /><published>2022-07-07T07:20:00+09:00</published><updated>2022-07-07T07:20:00+09:00</updated><id>https://ykkim97.github.io/etc-bubbling</id><content type="html" xml:base="https://ykkim97.github.io/etc-bubbling">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
오늘은 이벤트 버블링과 캡처링에 대해서 알아보겠습니다.&lt;br /&gt;
이게 도대체 무엇일까요?
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;버블링과-캡처링&quot;&gt;버블링과 캡처링&lt;/h2&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;onclick=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;alert('DIV에 할당된 클릭이벤트')&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;눌러봐&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 핸들러는 &amp;lt;div&amp;gt;에 할당이 되어있습니다. 하지만 그 안에있는 &amp;lt;p&amp;gt;태그를 눌러도 핸들러가 동작합니다.
뭔가 이상하지 않나요?? 분명 &amp;lt;p&amp;gt;태그를 눌렀는데 왜 &amp;lt;div&amp;gt;에 할당된 핸들러가 동작하는걸까요…?&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;onclick=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;alert('form')&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;FORM
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;onclick=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;alert('div')&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;DIV
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;onclick=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;alert('p')&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;P&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;또 다른 예시를 보면서 알아보겠습니다.&lt;br /&gt;&lt;br /&gt; 위 HTML코드를 보면 &amp;lt;form&amp;gt;태그 안에 &amp;lt;div&amp;gt;태그가 있고, 또 그 안에는 &amp;lt;p&amp;gt;태그가 있습니다.
그리고 각 태그에는 클릭 이벤트 핸들러가 할당되어 있는 상태입니다.
&lt;br /&gt;
&lt;br /&gt;
가장 안쪽에 존재하는 &amp;lt;p&amp;gt;태그를 클릭하면 다음 순서대로 동작합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;먼저 &amp;lt;p&amp;gt;의 핸들러가 동작합니다.&lt;/li&gt;
  &lt;li&gt;그 다음 상위태그인 &amp;lt;div&amp;gt;의 핸들러가 동작합니다.&lt;/li&gt;
  &lt;li&gt;그 다음 상위태그인 &amp;lt;form&amp;gt; 핸들러가 동작합니다.&lt;/li&gt;
  &lt;li&gt;document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
다음과 같은 과정으로 alert창이 p -&amp;gt; div -&amp;gt; form 순으로 3개가 열립니다. 이러한 흐름을 ‘이벤트 버블링’이라고 하는 것입니다.
가장 안쪽의 요소부터 가장 최상단까지 거슬로 올라가면서 발생하는 모양이 물속의 거품(bubble)과 닮았기 때문이라고 합니다.
&lt;br /&gt;
&lt;br /&gt;
‘버블링’과 반대로, 상위요소에서 하위요소로 이벤트가 전파되는 경우를 ‘이벤트 캡처링’이라고 합니다. 물론 자주쓰이는 경우는 아닙니다.&lt;/p&gt;

&lt;h2 id=&quot;event-flow&quot;&gt;Event Flow&lt;/h2&gt;

&lt;p&gt;DOM 이벤트는 3가지 단계가 존재합니다.
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Capture Phase (캡처링 단계)&lt;/li&gt;
  &lt;li&gt;Target Phase (타켓 단계)&lt;/li&gt;
  &lt;li&gt;Bubble Phase (버블링 단계)
&lt;br /&gt;
&lt;br /&gt;
기본적으로 이벤트 흐름은 Capture Phase 👉🏼 Target Phase 👉🏼 Bubble Phase 순으로 흐르게 됩니다.
그런데 여기서 의문이 생깁니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/17917009/178134486-b4271481-03e5-4e93-8ff8-12cdc5e603ee.JPG&quot; alt=&quot;이벤트 플로우 설명&quot; /&gt;
&lt;br /&gt;
DIV와 BODY와 HTML 모두 클릭 이벤트가 있다고 가정해보겠습니다.&lt;br /&gt;
div를 클릭하게 되면 위의 이벤트 흐름에 따라서 다음과 같이 이벤트가 발생할 것 입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;캡처링 단계에 의해 HTML 클릭이벤트 =&amp;gt; body 클릭이벤트 순으로 발생&lt;/li&gt;
  &lt;li&gt;타켓 단계에 의해 이벤트의 target인 div의 클릭이벤트 발생&lt;/li&gt;
  &lt;li&gt;버블링 단계에 의해 ody 클릭이벤트 =&amp;gt; HTML 클릭이벤트 순으로 다시 발생&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
그러면… 저 DIV하나 눌렀다고 클릭이벤트가 몇번 발생하게 되는거지…? &lt;br /&gt;
그렇습니다. 정말 복잡해집니다.&lt;br /&gt;&lt;br /&gt;
그래서 저 DIV, 즉 이벤트를 발생시킨 주체를 제외한 나머지 요소들은 이벤트가 캡처단계에서 발생될 것인지, 버블단계에서 발생될 것인지 선택할 수 있습니다.&lt;br /&gt;
기본적으로 브라우저는 ‘버블’이 기본값입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;querySelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;DIV&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;BODY&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;HTML&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 처럼 이벤트리스너의 첫번째 인자는 이벤트 타입, 두번째 인자는 리스너가 들어가는데 세번째인자로 true, false값을 넣어줄 수 있습니다.
기본값은 false이고 아무값도 넣지 않는다면 false인 상태로 ‘버블’인 것이고, true값을 넣어준다면 ‘캡처’가 적용되는 것입니다.
&lt;br /&gt;
위에서는 body에 true를 넣어서 캡처링을 적용한 것입니다.
&lt;br /&gt;
&lt;br /&gt;
이렇게 이벤트 캡처링과 버블링에 대해서 정리해보았습니다.
&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry><entry><title type="html">DOM이란?</title><link href="https://ykkim97.github.io/etc-dom" rel="alternate" type="text/html" title="DOM이란?" /><published>2022-07-07T07:20:00+09:00</published><updated>2022-07-07T07:20:00+09:00</updated><id>https://ykkim97.github.io/etc-dom</id><content type="html" xml:base="https://ykkim97.github.io/etc-dom">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;기타 포스팅입니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-firebasedbrules&quot;&gt;Firebase DB에서 값을 불러올 수 없는 문제 해결&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-browser&quot;&gt;브라우저 동작 원리&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-dom&quot;&gt;DOM이란?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-bubbling&quot;&gt;이벤트 버블링과 캡처링&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-whatisbundle&quot;&gt;번들링이 뭔데?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-processandthread&quot;&gt;프로세스와 쓰레드의 차이점&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-csrssrssg&quot;&gt;CSR, SSR, SSG의 차이&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./etc-libraryandframework&quot;&gt;라이브러리와 프레임워크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
DOM을 어느정도는 대충 알지만 누군가가 DOM이 무엇이냐고 다짜고짜 묻는다면 명확히 대답하기 어려웠습니다.
그래서 DOM에 대해서 공부한 내용을 간략히 정리해보려고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;dom-&quot;&gt;DOM ?&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
DOM은 Document Object Model의 약자입니다. 문서 객체 모델이라고도 합니다.
그냥 문서 객체 모델? 로 해석하려고 하면 잘 이해가 되지 않습니다.
&lt;br /&gt;
&lt;br /&gt;
쉽게 정리하면 DOM은 HTML 코드를 해석해서 요소들을 트리형태로 구조화해 표현하는 형식입니다. 
&lt;br /&gt;
&lt;br /&gt;
그러니까 브라우저가 HTML 코드를 해석해서 트리 형태로 구조화해서 표현하는 문서(데이터)를 생성하게 되는데 이게 DOM인 것입니다. 브라우저는 DOM을 통해서 화면에 웹 컨텐츠를 렌더링합니다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dom의-목적&quot;&gt;DOM의 목적&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
HTML코드를 해석해서 그대로 브라우저에 렌더링해주는 것이 브라우저의 역할인데 왜 중간에 DOM을 형성하는 걸까요?
&lt;br /&gt;
&lt;br /&gt;
자바스크립트를 사용해서 이 문서에 대한 스크립트를 작성할 수 있게 해주는 데 목적이 있기 때문입니다.
&lt;br /&gt;
&lt;br /&gt;
DOM은 자바스크립트를 사용해서 웹 컨텐츠를 추가, 수정, 삭제, 이벤트 처리 등을 정의할 수 있도록 제공되는
프로그래밍 인터페이스입니다. 
&lt;br /&gt;
&lt;br /&gt;
자바스크립트가 어떤 동작을 구현하면 DOM에 그 결과가 반영되어 웹브라우저 화면이 다시 렌더링됩니다. HTML 코드는 정적인데, 화면이 사용자와 동적인 상호작용을 하는데 DOM이 그 역할을 해주는 것입니다.
&lt;br /&gt;
&lt;br /&gt;
End.&lt;/p&gt;</content><author><name>ykkim97</name></author><category term="etc" /><summary type="html">기타 포스팅입니다. Firebase DB에서 값을 불러올 수 없는 문제 해결 브라우저 동작 원리 DOM이란? 이벤트 버블링과 캡처링 번들링이 뭔데? 프로세스와 쓰레드의 차이점 CSR, SSR, SSG의 차이 라이브러리와 프레임워크</summary></entry></feed>