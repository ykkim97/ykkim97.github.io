<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    <meta name="google-site-verification" content="G7pnGqDcQ3v7ojxCKwLRpb4iCN1X0kNH7kUnn0t0xRc" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    
    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- 웹폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- 폰트어썸 -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="IT 기술 블로그입니다." />
    <link rel="shortcut icon" href="https://ykkim97.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://ykkim97.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="YoungGwon's IT Tech Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="IT 기술 블로그입니다." />
    <meta property="og:url" content="https://ykkim97.github.io/search" />
    <meta property="og:image" content="https://ykkim97.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="IT 기술 블로그입니다." />
    <meta name="twitter:url" content="https://ykkim97.github.io/" />
    <meta name="twitter:image" content="https://ykkim97.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="YoungGwon's IT Tech Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "YoungGwon's IT Tech Blog",
        "logo": "https://ykkim97.github.io/"
    },
    "url": "https://ykkim97.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://ykkim97.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ykkim97.github.io/search"
    },
    "description": "IT 기술 블로그입니다."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://ykkim97.github.io/">YoungGwon's IT Tech Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-html" role="menuitem"><a href="/tag/html/">HTML</a></li>
    <li class="nav-css" role="menuitem"><a href="/tag/css/">CSS</a></li>
    <li class="nav-js" role="menuitem"><a href="/tag/javascript/">JS</a></li>
    <li class="nav-typescript" role="menuitem"><a href="/tag/typescript/">TS</a></li>
    <li class="nav-react" role="menuitem"><a href="/tag/react/">React</a></li>
    <li class="nav-nextjs" role="menuitem"><a href="/tag/nextjs/">NextJS</a></li>
    <li class="nav-git" role="menuitem"><a href="/tag/git/">Git</a></li>
    <li class="nav-etc" role="menuitem"><a href="/tag/etc/">Etc</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "etc-bubbling": {
        "title": "이벤트 버블링과 캡처링",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링오늘은 이벤트 버블링과 캡처링에 대해서 알아보겠습니다.이게 도대체 무엇일까요?버블링과 캡처링&lt;div onclick=\"alert('DIV에 할당된 클릭이벤트')\"&gt;    &lt;p&gt;눌러봐&lt;/p&gt;&lt;/div&gt;위의 핸들러는 &lt;div&gt;에 할당이 되어있습니다. 하지만 그 안에있는 &lt;p&gt;태그를 눌러도 핸들러가 동작합니다.뭔가 이상하지 않나요?? 분명 &lt;p&gt;태그를 눌렀는데 왜 &lt;div&gt;에 할당된 핸들러가 동작하는걸까요…?&lt;form onclick=\"alert('form')\"&gt;FORM  &lt;div onclick=\"alert('div')\"&gt;DIV    &lt;p onclick=\"alert('p')\"&gt;P&lt;/p&gt;  &lt;/div&gt;&lt;/form&gt;또 다른 예시를 보면서 알아보겠습니다. 위 HTML코드를 보면 &lt;form&gt;태그 안에 &lt;div&gt;태그가 있고, 또 그 안에는 &lt;p&gt;태그가 있습니다.그리고 각 태그에는 클릭 이벤트 핸들러가 할당되어 있는 상태입니다.가장 안쪽에 존재하는 &lt;p&gt;태그를 클릭하면 다음 순서대로 동작합니다.  먼저 &lt;p&gt;의 핸들러가 동작합니다.  그 다음 상위태그인 &lt;div&gt;의 핸들러가 동작합니다.  그 다음 상위태그인 &lt;form&gt; 핸들러가 동작합니다.  document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작합니다.다음과 같은 과정으로 alert창이 p -&gt; div -&gt; form 순으로 3개가 열립니다. 이러한 흐름을 ‘이벤트 버블링’이라고 하는 것입니다.가장 안쪽의 요소부터 가장 최상단까지 거슬로 올라가면서 발생하는 모양이 물속의 거품(bubble)과 닮았기 때문이라고 합니다.‘버블링’과 반대로, 상위요소에서 하위요소로 이벤트가 전파되는 경우를 ‘이벤트 캡처링’이라고 합니다. 물론 자주쓰이는 경우는 아닙니다.Event FlowDOM 이벤트는 3가지 단계가 존재합니다.  Capture Phase (캡처링 단계)  Target Phase (타켓 단계)  Bubble Phase (버블링 단계)기본적으로 이벤트 흐름은 Capture Phase 👉🏼 Target Phase 👉🏼 Bubble Phase 순으로 흐르게 됩니다.그런데 여기서 의문이 생깁니다.DIV와 BODY와 HTML 모두 클릭 이벤트가 있다고 가정해보겠습니다.div를 클릭하게 되면 위의 이벤트 흐름에 따라서 다음과 같이 이벤트가 발생할 것 입니다.  캡처링 단계에 의해 HTML 클릭이벤트 =&gt; body 클릭이벤트 순으로 발생  타켓 단계에 의해 이벤트의 target인 div의 클릭이벤트 발생  버블링 단계에 의해 ody 클릭이벤트 =&gt; HTML 클릭이벤트 순으로 다시 발생그러면… 저 DIV하나 눌렀다고 클릭이벤트가 몇번 발생하게 되는거지…? 그렇습니다. 정말 복잡해집니다.그래서 저 DIV, 즉 이벤트를 발생시킨 주체를 제외한 나머지 요소들은 이벤트가 캡처단계에서 발생될 것인지, 버블단계에서 발생될 것인지 선택할 수 있습니다.기본적으로 브라우저는 ‘버블’이 기본값입니다.const html = document.documentElement;const body = document.body;const div = document.querySelector('div');div.addEventListener('click', function () {  console.log('DIV')})body.addEventListener('click', function () {  console.log('BODY')}, true)html.addEventListener('click', function () {  console.log('HTML')})위 처럼 이벤트리스너의 첫번째 인자는 이벤트 타입, 두번째 인자는 리스너가 들어가는데 세번째인자로 true, false값을 넣어줄 수 있습니다.기본값은 false이고 아무값도 넣지 않는다면 false인 상태로 ‘버블’인 것이고, true값을 넣어준다면 ‘캡처’가 적용되는 것입니다.위에서는 body에 true를 넣어서 캡처링을 적용한 것입니다.이렇게 이벤트 캡처링과 버블링에 대해서 정리해보았습니다.End.",
        "url": "/etc-bubbling"
    }
    ,
    
    "etc-dom": {
        "title": "DOM이란?",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링DOM을 어느정도는 대충 알지만 누군가가 DOM이 무엇이냐고 다짜고짜 묻는다면 명확히 대답하기 어려웠습니다.그래서 DOM에 대해서 공부한 내용을 간략히 정리해보려고 합니다.DOM ?DOM은 Document Object Model의 약자입니다. 문서 객체 모델이라고도 합니다.그냥 문서 객체 모델? 로 해석하려고 하면 잘 이해가 되지 않습니다.쉽게 정리하면 DOM은 HTML 코드를 해석해서 요소들을 트리형태로 구조화해 표현하는 형식입니다. 그러니까 브라우저가 HTML 코드를 해석해서 트리 형태로 구조화해서 표현하는 문서(데이터)를 생성하게 되는데 이게 DOM인 것입니다. 브라우저는 DOM을 통해서 화면에 웹 컨텐츠를 렌더링합니다.DOM의 목적HTML코드를 해석해서 그대로 브라우저에 렌더링해주는 것이 브라우저의 역할인데 왜 중간에 DOM을 형성하는 걸까요?자바스크립트를 사용해서 이 문서에 대한 스크립트를 작성할 수 있게 해주는 데 목적이 있기 때문입니다.DOM은 자바스크립트를 사용해서 웹 컨텐츠를 추가, 수정, 삭제, 이벤트 처리 등을 정의할 수 있도록 제공되는프로그래밍 인터페이스입니다. 자바스크립트가 어떤 동작을 구현하면 DOM에 그 결과가 반영되어 웹브라우저 화면이 다시 렌더링됩니다. HTML 코드는 정적인데, 화면이 사용자와 동적인 상호작용을 하는데 DOM이 그 역할을 해주는 것입니다.End.",
        "url": "/etc-dom"
    }
    ,
    
    "etc-browser": {
        "title": "브라우저의 동작 원리",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링브라우저의 동작 원리브라우저는 웹사이트를 표시해주는 소프트웨어이며 웹 개발자들에게는 없어서는 안될 존재입니다.브라우저는 어떤 원리로 동작하게 되는 것일까요? 주소창에 주소를 입력했을 때 어떤 과정을 거쳐서 웹페이지가 화면에 보이게 되는 것일까요?브라우저의 종류브라우저는 크롬, 사파리, 파이어폭스, 오페라, 인터넷 익스플로러, 네이버웨일 등 여러가지가 있습니다. 현재는 크롬이 가장 많이 사용되고 있습니다.브라우저의 주 기능브라우저의 주 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저화면에 표시하는 것입니다. 여기서 자원은 보통 HTML문서이고 PDF나 이미지 등 다른형태도 포함될 수 있습니다. 자원의 주소는 URL에 의하여 정해집니다.브라우저는 HTML, CSS 명세에 따라서 HTML파일을 해석하고 표시합니다. 이 명세는 웹표준화기구(W3C)에 정하는데 과거에는 여러 브라우저가 각각 다른 방법으로확장했고 이는 호환성의 문제를 발생시켰습니다. 하지만 현재는 거의 대부분의 브라우저들이 표준화된 명세를 따르게 되었습니다.브라우저의 UI는 일반적으로 다음과 같이 구성되어있습니다.  주소 표시줄  뒤로가기,앞으로가기  중지, 새로고침  홈버튼  북마크브라우저의 UI는 표준 명세가 없음에도 계속해서 브라우저들끼리 서로를 모방하면서 거의 비슷한 UI를 가지게 되었습니다. 물론 특정한 브라우저가 가지고 있는기능도 있긴합니다.브라우저의 기본 구조  사용자 인터페이스 - 주소 표시줄, 뒤로가기, 앞으로가기, 중지, 새로고침, 홈버튼, 북마크 등  브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어  렌더링 엔진 - 요청한 컨텐츠를 표시함.  통신 - HTTP 요청과 같은 네트워크 호출에 사용됨.  UI 백엔드 - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.  자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행함.  자료저장소 - 자료를 저장하는 계층.렌더링 엔진렌더링엔진은 요청한 컨텐츠를 표시하는 녀석입니다. 파이어폭스의 경우 “개코”엔진, 사파리나 크롬은 “웹킷”엔진을 사용합니다.동작 과정에 대해렌더링엔진은 통신으로부터 요청한 문서의 내용을 얻는데 보통 문서내용은 8KB 단위로 전송됩니다.자, 렌더링엔진의 기본 동작 과정은 다음과 같습니다.  HTML문서를 파싱하여 DOM트리를 구축  CSS파일과 같은 스타일 요소를 파싱(CSSOM트리 구축)  이 둘을 합쳐서 렌더트리를 구축 (렌더트리는 문서를 시각적인 구성 요소로 만들어 주는 역할을 함)  렌더 트리 각 노드에 대해서 화면 상에 배치할 곳을 결정  UI 백엔드에서 렌더 트리의 각 노드를 그림.정리하면 브라우저가 서버로 부터 HTML문서를 전달받아서 HTML파서를 통해서 파싱하고 DOM트리를 생성합니다. 또한 CSS파일과 같은 스타일요소도 파싱되어 CSSOM트리를 생성합니다. 그다음에 DOM과 CSSOM이 합쳐져서 렌더트리를 구축하거 렌더트리를 배치합니다. 여기서 렌더트리는 위치와 크기를 가지고 있지 않기 때문에 어느 공간에위치해야할지 각 객체들에게 위치와 크기를 결정해줍니다. 이어서 렌더트리가 만들어져 레이아웃이 구성됬으면 UI 백엔드가 동작하여 렌더 트리의 각 객체를 화면의 픽셀값으로나타냅니다.자바스크립트는?HTML과 CSS는 렌더링엔진에서 처리가되는데 자바스크립트는 어떨까요?자바스크립트는 렌더링엔진에서 처리가 되는 것이 아니라 자바스크립트 엔진이 처리하는 것입니다. HTML파서가 End.참조한 자료 :https://bbangson.tistory.com/87.https://d2.naver.com/helloworld/59361.",
        "url": "/etc-browser"
    }
    ,
    
    "javascript-aboutthreejs": {
        "title": "Three.js에 대해서",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    요즘 새로 배워보고 싶은 것이 하나 생겼다. 그것은 바로 Three.js이다. 뭔가 웹사이트를 만들 때 조금 더 멋있고 인터렉티브하게 만들고 싶었고, 관련정보를 찾아보다가 이 three.js에 대해서 알게되었다. 그래서 배우면서 알게된 내용을 정리해 나가려고 한다.Three.js ?먼저 WebGL이라는 것에 대해서 알아볼 필요가 있다. WebGL은 웹 상에서 그래픽을 나타낼 수 있는 라이브러리다.그런데 이 WebGL API 자체가 완전 로우 레벨이라서 처음부터 하나하나 개발해 나가야 하고 코드양도 많으며 복잡하다고 한다.Three.js는 이 WebGL을 조금 더 쉽고 간편하게 사용할 수 있도록 도와주는 라이브러리인 것이다.공식사이트는 다음과 같다.Threejs.org.물론 Three.js 말고도 다른 라이브러리들이 있지만 현재는 Three.js가 가장 인기가 많다고 한다.저 공식사이트에는 이것을 활용하여 만들어진 사이트들을 확인할 수 있다.https://eyes.nasa.gov/apps/mars2020/.위 이미지에서 볼 수 있듯이 웹 상에서 화성을 표현하고 우주를 표현하는 등 멋진 표현을 웹사이트에 적용할 수 있는 것이다.three.js는 공식사이트에서 다운받거나 npm을 통해서 설치하는데 보통은 npm으로 다운받는 편이다.다음 글에서 three.js에 대해서 좀더 자세히 정리해보도록 하겠다.End.",
        "url": "/javascript-AboutThreejs"
    }
    ,
    
    "html-doctype": {
        "title": "DOCTYPE의 의미?",
            "author": "ykkim97",
            "category": "",
            "content": "HTML은 다음과 같이 구성되어 있습니다.     웹의 기본중의 기본! HTML에 대해서 알아보자    HTML 기본 태그들    DOCTYPE의 의미?DOCTYPE의 의미가 무엇일까? DOCTYPE은 Document Type의 약어로 문서의 유형을 정의하기 위해 사용하는 선언문(DTD, Documnet Type Definition)입니다.&lt;!DOCTYPE html&gt;&lt;!--     ...... --&gt;위처럼 html 문서 맨 처음에 선언하는데 이는 웹문서의 시작을 알려주고 웹 브라우저에서 처리할 문서가 html이며 어떤 버전으로 사용하였으니해당 방식으로 해석하라는 의미를 갖습니다. HTML5 이전에는 DOCTYPE을 선언하는 코드가 까다로웠지만 HTML5 부터는 간단하게 할 수 있게 되었습니다.End.",
        "url": "/html-doctype"
    }
    ,
    
    "etc-firebasedbrules": {
        "title": "Firebase DB에서 값을 불러올 수 없는 문제 해결",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링Firebase DB에서 값을 불러올 수 없는 문제 해결진행 중에 있는 프로젝트의 버그를 수정하기 위해 확인을 했는데 갑자기 문제가 발생했다…Firebase의 Realtime Database, Storage에 있는 데이터를 불러오지 못하는 문제였다. 처음에는 코드를 잘못만진게 아닌가 싶었는데,그런 이유는 아니었고 Firebase와 연동 자체가 안되는 문제였다. 갑작스러웠지만 인터넷 검색을 통해 문제를 해결하려고 노력했다.firebase 알림에 위와 같은 메세지가 와있는 것을 발견했는데, 보안규칙을 업데이트 해야한다는 것을 알았다.처음 데이터베이스를 사용할 때 잠금모드와 테스트모드중 테스트모드를 선택했는데 생각해보니 테스트모드는 30일이 지나면 데이터베이스에서 읽을 수 없도록 되어있었다.계속 유지하려면 보안 규칙설정을 해줘야한다.위처럼 보안규칙을 바꿔주었더니 다시 정상적으로 동작했다.물론 보안 규칙이 공개로 정의되어 있어 누구나 데이터베이스의 데이터를 도용, 수정, 삭제할 수 있지만 아직은 개발단계이기 때문에 일단 이렇게 수정해놓고 사용하기로 했다.Firebase 공식 문서 참조https://firebase.google.com/docs/rules/insecure-rules#database End.",
        "url": "/etc-firebasedbrules"
    }
    ,
    
    "javascript-hoisting": {
        "title": "호이스팅이란 , var, let, const 차이",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    호이스팅에 대해서“hoisting”의 사전적 의미는 “끌어올리기”라는 뜻이다. 일단 hoisting은 함수가 실행되기전에 안에 있는 변수들을 그 유효범위의 최상단으로 끌어올리는 것을 의미합니다.var 키워드의 문제점?ES6 이전까지는 변수를 선언할 때 var 키워드만 사용할 수 있었습니다. 하지만 var 키워드는 문제점이 있었습니다.1) 변수의 중복 선언 허용 문제var x = 1;var x = 2;console.log(x);x라는 동일한 이름의 변수가 선언된 것을 확인할 수 있는데, 먼저 선언된 x의 값이 변경되버리는 문제가 발생합니다.2) 함수 레벨 스코프var 키워드로 선언한 변수는 함수의 코드블록만 지역 스코프로 인정합니다. 함수를 제외하고 if나 for문안에 var 키워드를 사용하여 변수를 선언했다면? 지역변수로 취급을 하지않고 전역변수로 취급됩니다. 따라서 함수레벨스코프는 전역변수를 남발할 가능성을 높입니다.3) 변수 호이스팅var 키워드로 변수를 선언하면 변수 호이스팅에 의해 그 선언문이 범위의 최상단으로 끌어 올려진 것처럼 동작합니다. 변수 선언문 이전에 그 변수를 참조할 수 있다는 것인데, 에러를 발생시키지 않지만 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남기는 문제가 있습니다.let과 const의 등장이런 var의 문제를 해결하고자 ES6에서 let과 const를 도입하였습니다. let 키워드부터 살펴보겠습니다.let은 변수 중복 선언을 금지하고, 함수의 코드블록만 지역스코프로 인정하는 var와 달리 모든 코드블록을 지역스코프로 인정하는 블록레벨스코프를 따릅니다.또한 let키워드로 선언한 변수는 “선언”과 “초기화”단계가 분리되어 진행됩니다. 런타임 이전에 자바스크립트 엔진에 의해 선언단계가 먼저 진행되지만 초기화단계는 실제 변수 선언문에 도달했을 때 실행됩니다.let 키워드로 선언한 변수는 스코프의 시작부터 초기화단계가 시작되는 시점(변수 선언문)까지 변수를 참조할 수 없습니다. 이 구간을 일시적 사각지대(Temporal Dead Zone)라고 합니다.이번엔 const 키워드를 알아보겠습니다.const 키워드는 상수를 선언하기 위해서 사용되는데, 꼭 상수만을 위해 사용하는 것은 아닙니다.const는 대부분 let과 동일하지만 const 키워드로 선언된 변수는 꼭 선언과 동시에 초기화를 해주어야하고 변수의 재할당이 불가능합니다. 주의해야할 점이 있는데, const로 선언된 변수에 원시값을 할당한 경우는 값을 변경하지 못하는게 맞지만 const로 선언된 변수에 객체를 할당한경우 값을 변경할 수 있습니다. const는 재할당을 금지하는 것이지 불변을 의미하는 것이 아닙니다.그럼 무엇을 보통 쓸까?변수 선언은 기본적으로 const를 사용하는 것이 좋고 let은 재할당이 필요할 때 사용하는 것이 좋습니다. 추가적으로 var는 권장하지 않는 방법입니다.End.",
        "url": "/javascript-hoisting"
    }
    ,
    
    "javascript-eventloop": {
        "title": "JS Event Loop, 자바스크립트 동작 원리",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    JS Event Loop에 대해서Javascript Engine?일단 Javascript Engine과 Rendering Engine은 다릅니다. Rendering Engine(Layout Engine)은 HTML과 CSS로 작성된 마크업 관련 코드를 웹 페이지에 렌더링하는, 그려주는 역할을 하는 것이고 반면 Javascript Engine은 자바스크립트로 작성된 코드를 해석하고 실행시켜주는 인터프리터입니다.구글의 V8과 같은 자바스크립트엔진은 Call Stack, Task Queue, Heap으로 크게 나뉘고 추가적으로 Event Loop라는것이 있는데 Task queue에 들어가는 task들을 관리합니다.Call Stack자바스크립트는 한개의 Call Stack을 사용합니다. 코드 요청이 들어올 때마다 순차적으로 Call Stack에 담아서 처리합니다. 메소드가 실행이되면 Call Stack에 새로운 프레임이 생기고, push되고 메소드의 실행이 종료되면 해당 프레임은 pop됩니다.Heap(Memory Heap)동적으로 생성된 객체는 Heap에 할당이 됩니다. 구조화 되지 않는 더미같은 메모리 영역을 힙(heap)이라고 합니다. 정리하면 변수 선언, 함수 저장, 호출 이런 작업이 발생하는 공간입니다.Task Queue(Event Queue)처리해야하는 Task들을 임시로 저장하는 대기 큐가 존재합니다. 이것을 Task Queue라고 합니다. 이 Task Queue에 존재하는 Task들은 Call Stack이 비어졌을 때 대기 큐에 들어온 순서대로 Call Stack에 올려져서 수행됩니다. 자바스크립트에서는 비동기적으로 호출되는 함수들은 Call Stack으로 바로들어가지 않고 Task Queue에 들어가게 됩니다. 예를들어 Ajax요청코드, 이벤트리스너, setTimeout같은 것들이 있습니다. 결론자바스크립트 코드가 실행되면 Call Stack에 하나씩 들어가서 처리가되는데 Ajax요청코드, 이벤트리스너, setTimeout같은 것들은 Task Queue에 들어가서 대기합니다. Event Loop가 Call Stack이 비어있는지 확인하고 비어있다면 Task Queue에서 하나씩 Call Stack으로 보냅니다. 보내진 작업은 똑같은 과정을 거쳐서 처리가 되는 것입니다. End.",
        "url": "/javascript-eventloop"
    }
    ,
    
    "git-githubissuelabel": {
        "title": "Github Label별 의미",
            "author": "ykkim97",
            "category": "",
            "content": "Git은 다음과 같이 구성되어 있습니다.     Github Label별 의미Github 기본 Label들프로젝트를 하면서 많은 이슈가 발생하게 되고 이런것을 관리하는 것의 필요성을 느끼고 이슈관리에 대해서 공부하던 중 이슈에 라벨이라는 것을 달 수 있게 되어있었다. 여러가지가 있었는데 다음과 같다.깃허브의 이슈, PR(Pull Request)에 Label을 지정할 수 있다. 제공되는 라벨은 다음과 같다.            라벨      의미                  bug      예기치 않은 문제 또는 의도하지 않은 동작(버그)을 나타냅니다.              documentation      문서를 개선하거나 추가 할 필요가 있음을 나타냅니다.              duplicate      해당이슈 또는 PR이 기존에 있음을 나타냅니다.              enhancement      새로운 기능 요청을 나타냅니다.              good first issue      처음 기여해볼 사람에게 좋은 문제를 나타냅니다              help wanted      관리자가 문제 또는 PR 요청에 대한 도움을 원함을 나타냅니다.              invalid      이슈 또는 PR 요청이 더 이상 관련이 없음을 나타냅니다.              question      이슈 또는 풀 요청에 추가 정보가 필요함을 나타냅니다.              wontfix      문제 나 PR 요청에서 작업이 계속되지 않음을 나타냅니다.      End.",
        "url": "/git-githubissuelabel"
    }
    ,
    
    "react-usestate": {
        "title": "useState에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해useState?useState로 데이터를 저장해보자.우리는 보통 데이터를 저장할 때 다음과 같이 변수에 데이터를 저장합니다.let data = 'test data';이것은 기본적인 방법입니다. 리액트에서는 이것 말고 state라는 것을 만들어서 데이터를 저장할 수 있습니다.import { useState } from \"react\";function App() {    const [data, setData] = useState('test data');    return (        &lt;div&gt;            &lt;h3&gt;{data}&lt;/h3&gt;        &lt;/div&gt;    )}위 코드는 useState라는 훅을 사용하는 한 예제입니다.먼저 useState를 import를 합니다. 그리고 []안에 data와 setData, 이 두가지의 값이 올 수 있는데 첫번째 값은 data는 초기값에 해당하고,두번째 값인 setData는 data라는 값을 변경할 때 사용하는 함수입니다. data의 초기값으로는 현재 ‘test data’라는 문자열이 인자로 들어와 있는상태입니다.이렇게 정의하고 data라는 값을 사용하면 끝입니다. 사실 별거 없습니다.실제로 확인해보면 ‘test data’라는 문자열이 화면에 보여질 것입니다.setState위에서 사용했던 예제 코드에 버튼을 하나 추가해보겠습니다.import { useState } from \"react\";function App() {    const [data, setData] = useState('test data');    return (        &lt;div&gt;            &lt;h3&gt;{data}&lt;/h3&gt;            &lt;button onClick={() =&gt; setData('change data')}&gt;change&lt;/button&gt;        &lt;/div&gt;    )}이 버튼은 onClick 이벤트를 발생합니다. 클릭 시에는 setData()가 실행될 것입니다.setData함수는 위에서 설명했듯이 data라는 state의 값을 변경하는데 사용되는 함수 입니다. 함수의 파라미터로 문자가 변경되었다는 것을 나타내보기위해‘change data’라는 문자열을 집어넣었습니다. 이렇게 하면 버튼을 클릭했을 때 ‘change data’로 data의 값이 변경될 것입니다.실제로 확인해보면 값이 변경될 것입니다.state를 사용하는 이유?state를 사용하는 이유가 무엇일까요?사실 일반적인 변수로 저장해서 사용하는 것이 더 간단해 보이기도 합니다.그러나 state는 변경이 생길 경우 그 state를 사용하는 html을 자동으로 재렌더링 해줍니다.일반적인 변수를 사용하고 그 변수를 데이터바인딩했다고 가정할 경우 변수를 변경 후 html에도 변경사항을 반영하려면 직접 반영할 수 있도록 코드를 추가해줘야합니다. 하지만 state를 사용하면 추가적인 코드없이 자동으로 html을 재렌더링 해주기 때문에 UI를 개발할 때 편리하고 부드럽게 동작할 수 있습니다.물론 모든 데이터를 state로 저장할 필요는 없습니다. 상황에 따라서 사용하면 되는데 데이터가 자주 변경될 것 같은 데이터는 state를 사용하면되고, 별로 안바뀔거같은데이터는 변수로 저장해도 무방합니다. End.",
        "url": "/react-usestate"
    }
    ,
    
    "react-lazysuspense": {
        "title": "React - lazy, Suspense에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React - lazy, Suspense이번 포스팅에서는 lazy와 Suspense에 대해서 알아보겠습니다.React로 개발한 사이트들은 기본적으로는 SPA(Single Page Application)입니다.사이트를 빌드하면 하나의 큰 JS파일, HTML, CSS파일 등이 생성이 됩니다.하나의 JS파일안에 모든 컴포넌트, 페이지, 여러 기능들이 모두 모여있게 되는데 이는 용량이 제법 크기 마련입니다. 그래서 사용자가 사이트 메인페이지에 접속하게 되면 그 큰 JS파일을 받아야하기 때문에 초기 로딩속도가 느릴 수 있습니다. 따라서 아무것도 없는 흰 화면을 오래볼 가능성이 있습니다.따라서 이 하나의 JS파일을 분할을 하게되면 이런 문제점을 조금은 해결할 수 있습니다.이것은 당장 필요없는 페이지를 천천히 로드할 수 있도록 하면되는데 lazy라는 함수를 사용하면 됩니다.아래 예시를 보겠습니다.Detail이라는 페이지가 있습니다. 기본적으로는 다음과 같이 import를 하는 것이 맞습니다.import Detail from \"./routes/Detail\";하지만 이 Detail페이지가 당장 필요하지 않은 페이지라면 다음과 같이 lazy()라는 함수를 이용할 수 있습니다.import React, { lazy, Suspense } from 'react';const Detail = lazy(() =&gt; import('./routes/Detail.js'));이렇게 하게 되면 Detail페이지가 필요해질 때 import를 하게 됩니다.이런식으로 import를 하게 되면 초기로딩속도를 개선할 수 있습니다.물론 사이트를 발행할 때도 하나의 jS가 아니라 별도의 JS파일로 분리가 됩니다.Suspense물론 lazy로 import하는 방식도 단점이 있을 수 있습니다.Detail페이지가 필요해지는 시점에서는 약간의 지연시간이 발생할 수 있습니다.초기에 import되지 않고 필요해지는 시점에서 import를 하기 때문입니다.지연되는 시간동안 사용자는 역시 흰 화면을 보게될 것입니다.이런 경우 Suspense를 활용하여 로딩페이지를 띄워주면 좋을 것입니다.&lt;Route exact path='/detail' element={  &lt;Suspense fallback={&lt;div&gt;로딩중입니다. 조금만 기다려주세요!&lt;/div&gt;}&gt;    &lt;Detail /&gt;  &lt;/Suspense&gt;}&gt;&lt;/Route&gt;위와 같이 Detail페이지를 Suspense안에 넣어주면 됩니다. 추가로 fallback이라는 것의 값으로 로딩되는 동안에 사용자에게 보여질 메세지를 넣어주면 됩니다.End.",
        "url": "/react-lazysuspense"
    }
    ,
    
    "css-blockinline": {
        "title": "block과 inline의 차이점",
            "author": "ykkim97",
            "category": "",
            "content": "CSS는 다음과 같이 구성되어 있습니다.     CSS의 의미와 적용방법    block과 inline의 차이점block과 inline의 차이오늘은 block과 inline에 대해서 알아보겠습니다.display값으로 여러가지가 있지만 이번글에서는 block과 inline에 대해서만 알아볼 것입니다.display : block먼저 block인데,block은 무조건 한 줄을 모두 차지합니다. 따라서 다음 요소는 줄바꿈이 되게됩니다.div태그가 대표적인 예시입니다.display : inlineinline은 한줄 전체를 차지하는 것이 아니라 해당 텍스트만큼만 자리를 차지합니다. 예로 span태그가 있습니다.inline 태그는 width와 height를 명시할 수 없습니다. 그리고 margin은 위아래엔 적용되지 않고 좌우만 적용됩니다.또한 padding도 보기에는 상하좌우 모두 적용되는 것처럼보이나, 위아래공간은 사실 차지하지 않습니다.display : inline-block마지막으로 inline-block은 inline속성과 block속성을 모두가진 속성입니다. 줄바꿈없이 한 줄에 다른 요소들을 배치할 수 있는 특징이 있고, width, height, margin-top, margin-bottom을 적용할 수 있습니다.End.",
        "url": "/css-blockinline"
    }
    ,
    
    "react-scrolltotop": {
        "title": "React - 페이지 이동시 최상단 스크롤 방법",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React에서 페이지 이동시 최상단 스크롤 방법프로젝트를 진행하던 도중 useNavigate()를 사용해서 페이지를 전환하던 도중에전환된 페이지의 스크롤 위치가 전 페이지의 스크롤 위치와 동일해지는 문제를 발견하였다. 구글에 검색해본 결과 해결방법이 잘 나와있었다.import { useEffect } from \"react\";import { useLocation } from \"react-router-dom\";export default function ScrollToTop() {    const { pathname } = useLocation();    useEffect(() =&gt; {        window.scrollTo(0, 0);    }, [pathname]);    return null;};다음과 같은 코드에 해당하는 ScrollToTop이라는 컴포넌트를 만들고import ScrollToTop from \"./components/common/ScrollToTop\";ReactDOM.render(  &lt;BrowserRouter&gt;    &lt;ScrollToTop /&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;,  document.getElementById('root'));ScrollToTop 컴포넌트를 라우터 내부에 넣어주면 된다.pathname을 인식하게 하기위해 꼭 컴포넌트를 라우터 내부에 넣어야한다고 한다.End.",
        "url": "/react-scrolltotop"
    }
    ,
    
    "react-bootstrapguide": {
        "title": "React Bootstrap 사용하기",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React에서 Bootstrap사용하기React에서 Bootstrap을 사용하는 방법을 알아보겠습니다.일단 Bootstrap을 설치합니다.터미널에 다음과 같이 입력하여 설치합니다.npm install react-bootstrap bootstrap그 다음 최상단 파일인 index.js 또는 App.js에 css를 import해주면됩니다.import 'bootstrap/dist/css/bootstrap.min.css';또는 index.html파일에 다음을 link시켜주면됩니다.&lt;link  rel=\"stylesheet\"  href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\"  integrity=\"sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\"  crossorigin=\"anonymous\"/&gt;React에서 Bootstrap을 사용할 때 주의할 점은 이후에 부트스트랩 컴포넌트를 복사붙여넣기하고 바로 확인해보면 에러가 발생합니다.추가적으로 해야할 것은 붙여넣은 컴포넌트를 따로 import해주어야한다는 것입니다.예시 :import { Navbar, Container, Nav, NavDropdown } from \"react-bootstrap\";이렇게 import하면 정상적으로 사용이 가능합니다.End!",
        "url": "/react-bootstrapguide"
    }
    ,
    
    "react-contextapi": {
        "title": "props가 번거로울 때 Context API를 사용해보자",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해props가 번거로울 때 Context API를 사용해보자React에서 하위컴포넌트에 데이터를 전달하고 싶을 때 우리는 props를 사용하여 하위컴포넌트에 전달합니다.만약 개발을 계속 진행하다가 하위컴포넌트가 많이 추가 될 때 props를 상위 컴포넌트로부터 해당 하위컴포넌트까지 props를 전달해야하는데 정말 번거로울 수 있습니다.이때 사용할 수 있는 방법이 Redux를 사용하거나 Context API를 사용하는 방법이 있습니다.이번 포스팅에서는 Context API에 대해서 알아보겠습니다.Context로 state를 props없이 공유하자.모든 하위 컴포넌트들이 props로 state를 전달하지 않아도 state를 사용할 수 있게 할 수 있습니다.let testContext = React.createContext();function App() {  let [test, setTest] = useState([1,2,3,4]);  return (    // .....code    &lt;testContext.Provider value={test}&gt;      &lt;AnotherComponent /&gt;    &lt;/testContext.Provider&gt;  )}일단 let testContext = React.createContext();와 같이 context를 만듭니다. 이는 “공유할 범위”의 느낌이라고 보면됩니다.위의 test라는 state를 하위컴포넌트인 AnotherComponent와 공유하고 싶을 때 AnotherComponent를 로 감쌉니다.그리고 value값으로 공유하고싶은 state를 작성합니다.그러면 감싸진 범위에 있는 하위 컴포넌트들은 state값을 그냥 가져다 쓸 수 있습니다.import React, {useContext} from 'react';function AnotherComponent(){  return (    // ....code    &lt;Test&gt;&lt;/Test&gt;  )}function Test(){  let hello = useContext(testContext);  return &lt;p&gt;{hello}&lt;/p&gt;}컴포넌트는 AnotherComponent의 하위 컴포넌트입니다. 공유된 state를 사용하려면 위와 같이 useContext Hooks를 변수에 담고, 그 변수를 가지고 데이터바인딩을 하면됩니다.컴포넌트가 외부파일로 분리되어 있다면?만약 하위컴포넌트가 외부파일에 작성되어있다면,export let textContext = React.createContext();이렇게 export를 사용하고 해당 컴포넌트에 import 시켜주면 사용할 수 있습니다.물론 Context API도 상황에 따라서는 오히려 번거로울 수도 있습니다. 상황에 맞게 props나 ContextAPI를 사용하는 것이 좋겠습니다.End.",
        "url": "/react-contextapi"
    }
    ,
    
    "react-gugudan": {
        "title": "React로 간단한 구구단게임 만들기",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React로 간단한 구구단게임 만들기!잠깐 시간을 내어 간단한 구구단게임을 만들어 보았다.기본적으로 React Hooks을 이용하여 만들었다.만들어본 결과는 위 사진과 같다. media query를 이용하여 반응형으로 만들어보았다.기본 구조import { useState } from 'react';import './App.css';function App() {  const [firstNumber, setFirstNumber] = useState(Math.ceil(Math.random() * 9));  const [secondNumber, setSecondNumber] = useState(Math.ceil(Math.random() * 9));  const [value, setValue] = useState(\"\");  const [result, setResult] = useState(\"\");  const onSubmit = (e) =&gt; {    e.preventDefault();    if (value === \"\") {      setResult('숫자를 입력해주세요!');    } else if(parseInt(value) === (firstNumber * secondNumber)) {      setResult('정답!!');      setFirstNumber(Math.ceil(Math.random() * 9));      setSecondNumber(Math.ceil(Math.random() * 9));      setValue(\"\");    } else {      setResult('땡! 다시 입력해보세요!');      setValue(\"\")    }  }  const onChange = (e) =&gt; {    setValue(e.target.value);  }  return (    &lt;div className=\"App\"&gt;      &lt;div className='container'&gt;        &lt;h1&gt;{firstNumber} X {secondNumber} 은?&lt;/h1&gt;        &lt;form onSubmit={onSubmit} className=\"form\"&gt;          &lt;span&gt;            &lt;input               className='input'              type=\"text\"              value={value}               onChange={onChange}            /&gt;          &lt;/span&gt;          &lt;button className='btn'&gt;입력!&lt;/button&gt;          &lt;div className='result'&gt;{result}&lt;/div&gt;        &lt;/form&gt;      &lt;/div&gt;    &lt;/div&gt;  );}export default App;App.js의 내용이다.일단 firstNumber와 secondNumber는 각각 첫 번째 숫자와 두 번째 숫자를 의미하고 value는 입력한 값, 그리고 result는 정답이 아닌지 맞는지 알려주는데 쓰인다.이들을 useState를 이용하여 4개의 state를 만들었다.firstNumber와 secondNumber의 초기값은 1부터 9까지의 랜덤한 값으로 주고 value와 result의 초기값은 빈 값으로 주었다. 입력한 값이 정답인지 판단하는 부분은 onSubmit함수이다.사실 이 부분이 끝이다.const onSubmit = (e) =&gt; {    e.preventDefault();    if (value === \"\") {      setResult('숫자를 입력해주세요!');    } else if(parseInt(value) === (firstNumber * secondNumber)) {      setResult('정답!!');      setFirstNumber(Math.ceil(Math.random() * 9));      setSecondNumber(Math.ceil(Math.random() * 9));      setValue(\"\");    } else {      setResult('땡! 다시 입력해보세요!');      setValue(\"\")    }  }value는 입력한 값이므로, 입력을 하지않고 submit을 했을 경우 숫자를 입력하지 않았기 때문에 ‘숫자를 입력해주세요!’라는 메세지를 띄워준다.그리고 value값이 첫번째수와 두번째수를 곱한 값과 같을 경우 ‘정답!!’이라는 메세지를, 다를 경우 ‘땡! 다시 입력해보세요!’라는 메세지를 보여주게 만들었다.여기서 parseInt(value)를 해준 이유는 value가 문자형이기 때문에 number타입으로 바꾸어 비교하기 위한 것이다.각각의 조건문에 따라 setState함수를 통해 값을 변경해주었다.스타일은 내 생각대로 적절하게 css작업을 했다.어렵지 않게 구구단 웹 게임을 만들어보았다. 완성!!!Sourse Code : https://github.com/ykkim97/React_GuGuDanEnd.",
        "url": "/react-gugudan"
    }
    ,
    
    "typescript-tupletype": {
        "title": "TypeScript - tuple 타입",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?tuple 타입tuple타입 지정하기let food : (string | boolean)[] = ['김치',true];food라는 array가 있습니다. array의 타입지정은 위와 같이 할 수 있습니다.string타입와 boolean타입이 들어갈 수 있는 것입니다. 여기서 첫번째값은 string, 두번째값은 boolean타입만 오도록 타입지정을 더 엄격하게 하고 싶다면 어떻게 할까요? 이럴 때 tuple타입을 쓰면 됩니다.let food : [string,boolean] = ['김치',true];대괄호안에 그 위치에 맞는 타입을 넣으면 됩니다.rest parameter - tuple타입function fun(...x : [string, number]) {    console.log(x);}func('Lee',26);rest parameter도 위와 같이 동일하게 tuple타입을 적용할 수 있습니다.array를 spread 연산자로 합칠 때let arr1 = [1,2,3,4];let arr2 : [number, number, ...number[]] = [5,6,7, ...arr1]array를 spread 연산자로 합칠 때는 위와 같이 타입지정하면 됩니다.tuple타입은 더 정확한 타입지정을 도와줍니다.End.",
        "url": "/typescript-tupletype"
    }
    ,
    
    "typescript-nevertype": {
        "title": "TypeScript - never타입?",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?never타입?타입에는 never타입이라는 것도 있습니다.함수에 붙이는데, 조건이 있습니다.   return을 하면 안됩니다.  함수의 실행이 종료되면 안됩니다.이런 조건을 가진 함수에 붙일 수 있는 타입이 never타입입니다.기본적으로 자바스크립트 함수 맨 마지막에는 “return undefined”가 숨겨져있습니다.따라서 2번조건이 맞는다면 1번도 자동으로 조건이 성립됩니다.function fun() {    console.log(\"hi\");}위의 예시는 return을 하지 않았지만, console.log()로 출력한 이후 함수의 실행이 종료되버리기 때문에 never타입을 쓸 수 없는 것이죠.그러면 도대체 어디에 쓸 수 있을까요?예를 들면 무한반복문일 경우나 에러를 발생시키는 함수가 있습니다.아래와 같이 말이죠.function fun1() {    while(true) {        console.log(\"hi\");    }}function fuc2() {    throw new Error(\"에러\");}사실 never타입은 거의 사용할 일이 없습니다.return을 하고 싶지 않다면 void타입을 사용하면 됩니다.function fun(param : string) {    if (typeof param === \"string\") {        console.log(param);    } else {        console.log(param);    }}위는 never타입이 나타나는 예시를 든 것입니다.fun()의 파라미터인 param의 타입은 “string”으로 지정했는데도 불구하고 narrowing을 사용하여 param이 string타입일 경우와 그렇지 않은 경우를나누어서 코드를 작성했습니다. param이라는 파라미터는 이미 string으로 지정했음에도 굳이 narrowing을 할 필요가 없죠.else안에 param은 never타입이 되있을 것입니다.// 함수선언식function 함수1() {    throw new Error()}//함수표현식let 함수2 = function () {    throw new Error()}또 다른 예시입니다. 함수1()은 함수선언식으로 작성했고 함수2()는 함수표현식으로 작성했습니다.함수1의 경우는 void타입이고, 함수2는 never타입으로 나타나게 됩니다.이번 글에서는 never타입에 대해서 알아보았습니다. 크게 사용할 일은 없겠지만 알아두면 괜찮을 것입니다.End.",
        "url": "/typescript-nevertype"
    }
    ,
    
    "typescript-interface": {
        "title": "TypeScript - interface에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?interface문법1. interface사용법type키워드를 통해서 타입을 변수처럼 작성할 수 있었습니다. “interface”라는 것으로도 할 수 있습니다.interface를 사용하면 Object의 타입을 편하게 지정할 수 있습니다.interface Line {    color : string,    width : number,}let greenLine : Line = { color : \"green\", width : 30 }“Line”이라고 하는 interface명을 지정하고 Object처럼 비슷하게 interface를 정의하면 됩니다.주의할 점은 인터페이스명은 대문자로 시작하여 작명합니다.2. interface의 확장성interface는 extends, 즉 확장이 가능합니다.만약 Animal interface &amp; Dog interface가 필요하다고 가정하면..interface Animal {    name : string,}interface Dog extends Animal{     age : number,}Dog interface 옆에 extends Animal이라고 작성했습니다. 이렇게 되면 Dog interface는 Animal interface를 상속받습니다.Dog interface는 부모의 “name : string”도 가지고 있는 동시에 “age : number”도 가지고 있게 되는 것입니다.3. type와 interface의 차이점?type과 interface의 차이점이 무엇일까요?extends하는 법이 조금 다릅니다.interface의 경우는 위에서 처럼 “extends”를 쓰면됩니다.type의 경우는 “&amp;”을 사용하여 두 object를 합칠 수 있습니다.type Animal = {   name :string } type Dog = Animal &amp; { age : number }그런데 사실 interface의 경우도 “&amp;”기호로 합칠 수 있습니다..주의할점이 있다면 extends를 사용하면 타입끼리 중복속성이 발견될 경우 에러를 내주는데 &amp; 쓰면 때에 따라 아닐 수도 있다는 것입니다.또한 interface는 타입명이 중복되는 것을 허용해주지만, type의 경우 중복선언을 허용하지 않습니다. 엄격하죠.interface는 중복이 될 경우 extends한 것처럼 합쳐집니다. 물론 속성이 중복되면 에러가 나고 type도 마찬가지로 에러가 발생합니다.End.",
        "url": "/typescript-interface"
    }
    ,
    
    "typescript-uniontype": {
        "title": "TypeScript - Union Type, any, unknown",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?Union Type, Any, unknown에 대해이번 글에는 Union Type, Any, unknown에 대해서 알아보겠습니다.Union Type앞서 Union Type에 대해서 언급한 적이 있습니다. Union Type은 “A 또는 B 타입이 들어올 수 있어요”라는 상황에서 사용할 수 있는데 “또는”이라는 것을 나타냅니다.“|” 기호를 통해 나타냅니다.let age : string | number = 100;age라는 변수는 100이라는 number타입을 할당해도 되고, “100”이라는 string타입을 할당해도 되는 것입니다.let arr : (number | string)[] = [\"A\",1,2];let obj : { data : (number | string) } = { data : \"534\" }Array와 Object의 경우에는 위처럼 타입을 정의하면 됩니다.any와 unknownlet aaa : any = 12;any타입은 그 어떤 타입이 와도 OK라는 뜻입니다.타입을 막 바꿔도 에러가 발생하지 않습니다. 에러가 나지 않으니 마냥 좋은 것이 아닙니다. 타입과 관련해서 버그가 발생할 경우 추적하기 힘들어지고타입스크립트를 사용하는 의미가 없는 것이죠. unknown이라는 타입도 있습니다. unknown 역시 any타입처럼 에러가 발생하지 않습니다. 그럼 차이점이 무엇일까요?unknown타입은 any타입을 제외한 다른 타입으로 선언한 변수에 할당할 수 없으며, unknown으로 선언된 변수는 프로퍼티에 접근이 불가하고, 인스턴스를 생성할 수 없습니다.정리하면, 아직 변수에 무엇이 들어갈지 애매할 때, 조금의 안전성을 가져가고 싶다면 unknown타입을 쓰는 것입니다. 많이 쓰진 않지만 any와 unknown에 대해 알아보았습니다.End.",
        "url": "/typescript-uniontype"
    }
    ,
    
    "typescript-basicsyntax": {
        "title": "TypeScript - 기본 타입 작성법",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?타입스크립트 - 타입 작성타입스크립트는 자바스크립트에 타입을 더한 언어입니다. 변수를 만들 때 변수의 타입을 지정가능합니다.변수에 타입 지정하기let myName : string = \"KYG\"myName이란 변수 뒤에 콜론과 함께 string이라는 타입을 적어주었습니다.간단합니다.변수명 : 타입 으로 작성하면되며, myName이라는 변수는 string타입이 된것입니다. 만약 myName변수에 숫자를 할당한다면 어떻게 될까요? 바로 에러가 발생하게 됩니다.타입의 종류에는 string, number, boolean, null, undefined 등이 있습니다.Array와 Object에 타입 지정하기Array와 Object에는 타입을 어떻게 지정할까요?역시 간단합니다.let members :string[] = ['kim', 'Lee','Choi']배열기호인 “[]”와 함께 배열 안에 들어갈 값에 대한 타입을 앞에 적어줍니다.만약에 여러 타입이 동시에 들어올 수 있는 경우는 Union Type을 사용하면되는데 숫자와 문자가 동시에 들어올 수 있다고 가정하면let exam :(string | number)[] = ['kim', 26,'Choi']Object는 어떻게 지정할까요?let 내정보 : { age : number } = { age : 20 }”{}”기호를 사용하고 안에다가 key와 value의 타입을 작성하면 됩니다.그런데 모든 변수에 타입을 지정해야하나요?사실 타입을 굳이 다 적지 않아도 되는데 이유는 변수를 생성할 때 Typescript가 타입을 자동으로 부여해줍니다. 하지만 타입을 적어주는게 좋긴합니다. 오늘은 타입을 지정하는 법을 알아봤습니다.감사합니다.End.",
        "url": "/typescript-basicsyntax"
    }
    ,
    
    "nexjs-redirectrewrite": {
        "title": "(NextJS) redirect와 rewrite",
            "author": "ykkim97",
            "category": "",
            "content": "NextJS는 다음과 같이 구성되어 있습니다.     (NextJS) redirect와 rewrite    오늘은 NextJS의 redirect와 rewrites 사용법에 대해 알아보겠습니다.redirect// next.config.js에 작성합니다./** @type {import('next').NextConfig} */const nextConfig = {  reactStrictMode: true,  async redirects() {    return [      {        source : \"/before\",        destination : \"/after\",        permanent : false      }    ]  }}module.exports = nextConfig위와 같이 사용하면되는데, async redirects로 설정해주어 사용하면됩니다.source부분은 url로 먼저 접근하는 주소이고 destination은 source로 접근할 경우 변경될 주소입니다./before로 접근하면 /after가 되는 것이죠.추가적인 redirect설정을 하고 싶다면 저 묶음을 배열에 추가해주면 됩니다.  참고ex) /before/:path =&gt; /after/:path (:path부분은 기존과 동일한 값으로 유지)ex) /before/:path* =&gt; /after/:path* (*를 붙여주는 경우 어떤값이 오더라도 뒷부분 모두를 반영)rewritesconst nextConfig = {  reactStrictMode: true,  async rewrites() {    return [      {        source : \"/api/movies\",        destination : `https://api.themoviedb.org/3/movie/popular?api_key=${API_KEY}`,      }    ]  }}rewrites는 redirect와 같은 level에 추가하면되고source값으로 불러오면 내부적으로 destination값을 호출하게됩니다.예를 들어, api-key와 같이 숨기고 싶은 값이 url에 있을 경우 실제 url을 숨기고 다른 url로 대체할 수 있습니다.End.",
        "url": "/nexjs-redirectrewrite"
    }
    ,
    
    "typescript-typekeyword": {
        "title": "Type 키워드로 타입을 변수에 담기",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?Type 키워드타입의 정의가 너무 길다면 Type Aliases로!타입스크립트에서 타입을 지정해줄 때 타입이 너무 길거나 작성한 타입이 나중에 재사용될 것 같다면 타입도 변수에 담아쓰는 것이 좋습니다.변수 만드는 것처럼 Type키워드를 사용합니다. 이를 Type Aliases(타입 별칭)이라 합니다.type Food = string | number | undefined;let food : Food = \"apple\";위 처럼 type이라는 키워드를 쓰고 변수에 담으면 끝!보통 타입은 대문자로 시작하는 것이 좋습니다. 이렇게 따로 저장해둔다면 코드 읽기도 편하고 똑같은 코드를 반복해서 적을 필요가 없겠죠?End",
        "url": "/typescript-typekeyword"
    }
    ,
    
    "typescript-asconst": {
        "title": "as const에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?as const 문법const student = {    name : \"Kim\"}function myFun(a : \"Kim\") {}myFun(student.name);위와 같이 student객체와 myFun이라는 함수를 만들었습니다.myFun함수의 매개변수 a의 타입은 “Kim”타입으로 지정하였습니다. 이후 myFun함수에 student.name을 전달하였습니다. 그런데 이는 에러를 발생시킵니다.student.name이라는 값은 분명 “Kim”인데 왜 에러가 발생하지? 라는 생각이 들 수도 있습니다. 여기서 분명히 해야하는 점은 myFun함수의 매개변수 a는 “Kim”이라는 값만 들어올 수 있다는 의미가 아니라 “Kim”이라는 타입만 들어올 수 있다는 의미입니다.student.name의 값은 “Kim”이지만 타입은 분명 string타입이기 때문에 에러가 발생하는 것입니다.이를 해결하기위한 방법은 여러가지가 있습니다.  student 객체의 타입에 직접 name을 “Kim” 타입으로 지정  Type assertion 사용  student객체에 as const 사용하기let student = {  name : 'kim'} as const;function myFun(a : 'kim') {}myFun(자료.name)위처럼 as const 를 object뒤에 붙이면 에러가 나지 않습니다.as const는 2개의 효과를 가지고 있습니다.  타입을 object의 value로 바꿔줍니다. (타입을 ‘kim’으로 바꿔줍니다)  object안에 있는 속성을 모두 readonly로 바꿔줍니다. (변경하면 에러나도록)이번 포스팅에서는 as const에 대해서 알아보았습니다.감사합니다.End.",
        "url": "/typescript-asconst"
    }
    ,
    
    "typescript-narrowing": {
        "title": "Type Narrowing",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?타입 좁히기 (Type Narrowing)Type Narrowing타입스크립트의 타입은 덜 정확한, 애매한 타입이 있을 수 있습니다. 하지만 타입스크립트는 엄격하기때문에 정확한 타입이 필요합니다. 그렇지 않으면 타입 에러가 발생하게 되죠.이렇게 타입 에러를 막기 위해 Type Narrowing이 필요합니다.Type Narrowing은 if문 등으로 타입을 하나로 정해주는 것입니다.function myFun(x :number | string){  if (typeof x === 'number') {    return x + 1  }   else if (typeof x === 'string') {    return x + 1  }  else {    return 0  }}if문으로 타입을 나누지 않고 그냥 return x + 1 처리하면 에러가 발생합니다.x는 number | string 타입이지 number 타입이나 string 타입이 아니라고 보면됩니다.따라서 조건문으로 타입 별로 처리를 나눠주면 에러를 피할 수 있습니다. 위 코드처럼 조건에 typeof를 꼭 쓸 필요는 없습니다.타입을 하나로 확정지을 수 있는 표현이라면 어떤 것도 Narrowing 역할을 할 수 있습니다.in, instanceof 등의 키워드도 사용이 가능합니다.Type Assertion물론 타입을 간편하게 assert할 수도 있습니다.Type Assertion 이라는 것을 사용하는 것인데, 변수 뒤에 as를 붙이는 것이죠.변수명 as string이렇게 쓰면 “이 변수의 타입을 string으로 생각해주세요”라는 뜻입니다. 하지만 실제로 타입을 바꿔주는 것은 아니기 때문에 조심해서 사용해야합니다.assertion을 남발하는 것은 좋지 않습니다.as 키워드를 사용하면 다음과 같은 특징이 있습니다.  as 키워드는 Union Type과 같은 복잡한 타입을 하나의 정확한 타입으로 좁혀주는 역할을 합니다. 그래서 number타입인 변수를 as string 으로 바꾸려고한다면 에러가 발생합니다.  사실 임시로 타입을 해제시키는 용도입니다. 실제 코드의 실행결과는 as가 있을 때나 없을 때나 동일합니다.정리하자면 as를 사용하면 간편하지만, 정확한 코드를 위해 Narrowing을 사용하는 것이 좋습니다. 왜 타입에러가 나는지 정말 모르겠을 때 임시방편으로 사용하거나, 내가 어떤 타입이 들어올지 확실하게 알고 있으나, 컴파일러 에러가 발생하는 경우 비상용으로 사용하면 되겠습니다.End.",
        "url": "/typescript-narrowing"
    }
    ,
    
    "typescript-basic": {
        "title": "TypeScript란?",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?1. 타입스크립트(TypeScript)란?타입스크립트(TypeScript)란 자바스크립트(JavaScript)에 타입을 적용한 언어로, 자바스크립트의 확장버전이라고 말할 수도 있을 것입니다.2. 타입스크립트를 쓰는 이유?제가 예시를 들어보겠습니다.문자와 숫자의 연산은 자바스크립트에서 가능합니다.자바스크립트가 알아서 문자를 숫자로 바꿔주기 때문입니다.물론 이러한 자바스크립트의 유연성이 편리할 때도 있습니다. 하지만 코드가 길어져 규모가 커지고 협업을 하는 경우 단점이 됩니다.이러한 경우 타입스크립트를 쓰면 문자와 숫자를 연산할 수 없다는 에러를 띄워줍니다.또한 타입스크립트의 에러메세지는 자바스크립트에 비해서 엄격하게 타입을 체크해주기 때문에 정확하고 추적하기 쉬운 에러메세지를 띄워줍니다. 또한 오타 교정도 해줍니다.3. 타입스크립트 설치기본적인 html,css,js를 가지고 웹 개발을 한다고 가정할 경우  node.js를 설치합니다.(최신버전으로)  에디터 터미널에 npm install -g typescript 입력하여 설치합니다.  .ts로 끝나는 타입스크립트 파일을 생성합니다.  tsconfig.json 파일을 하나 만들어 줍니다.  tsconfig.json 파일안에 다음 코드를 입력합니다.{    \"compilerOptions\" : {        \"target\" : \"es5\",        \"module\" : \"commonjs\",    }}React 프로젝트에서 Typescript 사용할 경우이미 존재하는 React 프로젝트에 설치할 경우에는프로젝트 터미널에서 다음 명령을 입력해주면 됩니다.npm install --save typescript @types/node @types/react @types/react-dom @types/jest그냥 React 프로젝트를 새로만든다면새 프로젝트 폴더를 만들고 에디터 터미널을 열고 다음처럼 입력해주면 됩니다.npx create-react-app my-app --template typescript3. 타입스크립트 컴파일하기타입스크립트 자체는 브라우저가 읽지 못합니다. 따라서 ts파일을 js로 변환해주어야합니다. 컴파일을 하는 것이죠.터미널에tsc -w 라는 명령어를 입력하고 켜놓으면코드를 저장할때마다 js파일로 변환됩니다.파일을 사용할때는 변환된 js파일을 사용합니다.tsconfig.json 파일은 ts에서 js로 컴파일 시에 옵션을 설정할 수 있습니다.",
        "url": "/typescript-basic"
    }
    ,
    
    "react-mkcomponent": {
        "title": "React 컴포넌트 만들기",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React 컴포넌트 만들기React의 본질은 사용자 정의 태그를 만드는 것입니다.1. 왜?import './App.css';function App() {  return (    &lt;div className='app'&gt;      &lt;header&gt;        &lt;h1&gt;&lt;a href='/'&gt;WEB&lt;/a&gt;&lt;/h1&gt;      &lt;/header&gt;      &lt;nav&gt;        &lt;ol&gt;          &lt;li&gt;&lt;a href='/read/1'&gt;html&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href='/read/1'&gt;css&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href='/read/1'&gt;javascript&lt;/a&gt;&lt;/li&gt;        &lt;/ol&gt;      &lt;/nav&gt;      &lt;article&gt;        &lt;h2&gt;Welcome&lt;/h2&gt;        Hello, WEB      &lt;/article&gt;    &lt;/div&gt;  );}export default App;위의 예시의 경우에는 코드 라인 수가 짧은 편이지만, 규모가 커져 백만 줄, 천만 줄…. 이상으로 라인 수가 길어진다면 한눈에 보기힘들어 가독성이 떨어지고 복잡해집니다. 이로 인해서 코드를 수정하기도 힘들어지게 되겠죠… React의 본질은 사용자 정의 태그를 만드는 것입니다.2. 방법function App() {  return (    &lt;div className='app'&gt;      &lt;Header /&gt;      &lt;Nav /&gt;      &lt;Article /&gt;    &lt;/div&gt;  );}간단해진 App 컴포넌트위와 같이 &lt;Header&gt; , &lt;Nav&gt; , &lt;Article&gt;로 코드를 짧게 줄일 수 있습니다.아래와 같이 각각 함수로 만들어 주면 됩니다.function Header() {  return (    &lt;header&gt;      &lt;h1&gt;&lt;a href='/'&gt;WEB&lt;/a&gt;&lt;/h1&gt;    &lt;/header&gt;  )}function Nav() {  return (    &lt;nav&gt;      &lt;ol&gt;        &lt;li&gt;&lt;a href='/read/1'&gt;html&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href='/read/1'&gt;css&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href='/read/1'&gt;javascript&lt;/a&gt;&lt;/li&gt;      &lt;/ol&gt;    &lt;/nav&gt;  )}function Article() {  return (    &lt;article&gt;      &lt;h2&gt;Welcome&lt;/h2&gt;      Hello, WEB    &lt;/article&gt;  )}function App() {  return (    &lt;div className='app'&gt;      &lt;Header /&gt;      &lt;Nav /&gt;      &lt;Article /&gt;    &lt;/div&gt;  );}함수로 만들 때 주의할 사항은 함수명(컴포넌트)은 항상 대문자로 시작해야 한다는 것입니다.일반 html태그와 차이를 주는 것입니다.함수를 만들고 App컴포넌트에 일반 태그 쓰듯이 붙여주면 됩니다.이렇게 하면 코드의 가독성도 좋고 코드를 반복해서 사용할 필요없이 계속해서 컴포넌트를 독립된 부품처럼 가져다 쓸 수 있습니다.또한 컴포넌트를 공유할 수 있으므로 생산성도 높아집니다.",
        "url": "/react-mkcomponent"
    }
    ,
    
    "css-basic": {
        "title": "CSS의 의미와 적용방법",
            "author": "ykkim97",
            "category": "",
            "content": "1. CSS란?CSS는 Cascading Style Sheets 라는 의미로, html에 스타일을 지정할 때 사용하는 언어입니다.CSS를 사용하는 방법은 내부 스타일시트, 외부 스타일시트, 인라인 스타일시트가 있습니다.2. 내부 스타일시트내부 스타일시트는 말 그대로 html문서 내부에 css를 직접 작성하는 방법입니다.아래처럼 head태그안에 style태그를 입력하고 그 안에 css 스타일링을 해주면 됩니다.간편하게 사용할 수 있는 장점이 있습니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        p {            color: tomato;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;안녕하세요!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;3. 외부 스타일시트확장자가 .css로 끝나는 별도의 파일을 만들어 연결하는 방법입니다.p {    color: tomato;}위처럼 따로 css파일을 만들고,&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;안녕하세요!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;link 태그의 href속성에 css파일의 경로를 적어주면 끝!4. 인라인 스타일시트&lt;body&gt;    &lt;p style=\"color: tomato;\"&gt;안녕하세요!&lt;/p&gt;&lt;/body&gt;인라인 스타일시트는 html태그의 속성에 바로 스타일을 작성하는 방법입니다.End.",
        "url": "/css-basic"
    }
    ,
    
    "html-basic-tags": {
        "title": "HTML 기본 태그들",
            "author": "ykkim97",
            "category": "",
            "content": "HTML은 다음과 같이 구성되어 있습니다.     웹의 기본중의 기본! HTML에 대해서 알아보자    HTML 기본 태그들    DOCTYPE의 의미?HTML 기본 태그들1. &lt;head&gt;1) 태그문서의 정보를 담고 있는 태그로 웹을 설계하고 구축할 때 필수적으로 들어가야 되는 문서의 정보입니다.2) 태그문서의 제목을 나타내는 태그입니다. 웹페이지 탭을 띄우게 되면 웹의 제목이 나타나게 됩니다.3) 태그주로 css 파일을 연결할 때 사용합니다. 물론 다른 외부요소를 연결하는 데에도 사용합니다.4) ",
        "url": "/html-basic-tags"
    }
    ,
    
    "html-basic": {
        "title": "웹의 기본중의 기본! HTML에 대해서 알아보자",
            "author": "ykkim97",
            "category": "",
            "content": "HTML은 다음과 같이 구성되어 있습니다.     웹의 기본중의 기본! HTML에 대해서 알아보자    HTML 기본 태그들    DOCTYPE의 의미?HTML은 HyperText Markup Language의 약자로 웹을 이루는 가장 기초적인 구성요소입니다. 웹 컨텐츠의 의미와 구조를 정의할 때 사용합니다.HTML로 기본 구조를 잡고 CSS로 스타일링 하며 기능 및 동작은 JavaScript를 이용하게 됩니다.HTML요소의 형식은 다음과 같습니다. 컨텐츠 위 처럼 태그안에 컨텐츠가 들어가게 되고, 태그에는 여러 속성들이 들어갈 수 있습니다.물론 위처럼 열고 닫는 태그만 존재하는 것은 아닙니다.컨텐츠가 없는 태그도 존재하죠.이를 빈 태그(Empty Tag)라고도 합니다.HTML 문서는 파일의 확장자가 html로 끝나며 최상위 태그로 &lt;html&gt;을 사용한다. 그 하위에 &lt;head&gt; 태그와 &lt;body&gt; 태그를 컨텐츠로 가지고 있습니다. 태그는 문서를 설명하는 태그로 제목이나 키워드와 같은 정보를 담고  태그에는 문서의 내용이 위치합니다.",
        "url": "/html-basic"
    }
    ,
    
    "react-basic": {
        "title": "React란?",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해1. ReactReact는 Facebook에서 제공 중인 자바스크립트 라이브러리이자 웹 프레임워크이다.React를 사용하지 않더라도 HTML, CSS, JS 만으로도 웹페이지를 만들 수 있지만 React를 이용해 사용자와 상호 작용할 수 있는 동적인 UI를 쉽게 개발할 수 있기 때문에 많이 사용된다. React 말고도 Vue나 Angular와 같은 프레임워크들이 사용되고 있는데 현재 가장 많이 사용되고 있는 것은 React인 것이다.2. React의 특징1. Data flowReact는 단방향 데이터 흐름을 가지고 있다고 한다.Angular.js와 같은 양방향 데이터 바인딩은 개발 규모가 커질수록 데이터의 흐름을 추적하기 힘들고 복잡해질 수 있지만 React의 경우는 복잡한 어플리케이션의 경우에도 데이터 흐름에서 일어나는 변화를 보다 예측 가능하도록 단방향 흐름을 가지도록 했다고함.2. 컴포넌트 기반 구조컴포넌트란 독립적인 소프트웨어 모듈을 의미한다.React의 경우 UI를 여러 개의 컴포넌트로 나누어서 개발한다. 즉 여러 컴포넌트를 모아서 하나의 페이지를 구성하는 것이다. 컴포넌트 별로 나누어져 있기 때문에 전체 코드를 파악하기 쉽다.그리고 코드를 반복해서 작성할 필요없이 컴포넌트를 import하여 간단히 사용할 수 있다.애플리케이션이 복잡해지더라도 코드의 관리와 유지보수가 용이하다는 장점이 있다.3. Virtual DOMDOM은 Documnet Object Model이며 html,css,xml등을 트리 구조로 인식하고 데이터를 객체로 간주하고 관리한다.React는 이 DOM TREE 구조와 같은 구조체를 Virtual DOM으로 가지고 있다. Virtual DOM은 가상의 DOM으로 이벤트가 발생할 떄 마다 Virtual DOM을 만들고 다시 그릴 때마다 실제 DOM과 비교하여 변경이 필요한 최소한의 변경사항만 실제 DOM에 반영하여 어플리케이션의 효율성과 속도를 개선할 수 있다고 한다.4. Props 와 State      Props    Props는 부모 컴포넌트에서 자식 컴포넌트로 전달해주는 데이터이다.    쉽게 읽기 전용 데이터라고 생각하면 될 것 같다. 자식 컴포넌트에서 전달받은 props는 변경이 불가능하고 props를 전달해준 최상위 부모 컴포넌트만 props를 변경할 수 있습니다.        State    State는 컴포넌트 내부에서 선언하며 내부에서 값을 변경할 수 있습니다. state는 동적인 데이터를 다룰 때 사용하며, 사용자와의 상호작용을 통해 데이터를 동적으로 변경할 때 사용합니다.  5. JSXReact는 JSX문법을 사용할 수 있는데 Javascript에 XML을 추가한 확장한 문법이라고 보면 된다.",
        "url": "/react-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ykkim97.github.io/">YoungGwon's IT Tech Blog</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search YoungGwon's IT Tech Blog</h1>
            <p class="subscribe-overlay-description">
            포스트 검색하기 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
                id="searchtext" type="text" name="searchtext"  
                placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
