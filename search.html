<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    <meta name="google-site-verification" content="G7pnGqDcQ3v7ojxCKwLRpb4iCN1X0kNH7kUnn0t0xRc" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    
    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- 웹폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- 폰트어썸 -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="IT 기술 블로그입니다." />
    <link rel="shortcut icon" href="https://ykkim97.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://ykkim97.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="YoungGwon's IT Tech Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="IT 기술 블로그입니다." />
    <meta property="og:url" content="https://ykkim97.github.io/search" />
    <meta property="og:image" content="https://ykkim97.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="IT 기술 블로그입니다." />
    <meta name="twitter:url" content="https://ykkim97.github.io/" />
    <meta name="twitter:image" content="https://ykkim97.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="YoungGwon's IT Tech Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "YoungGwon's IT Tech Blog",
        "logo": "https://ykkim97.github.io/"
    },
    "url": "https://ykkim97.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://ykkim97.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ykkim97.github.io/search"
    },
    "description": "IT 기술 블로그입니다."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://ykkim97.github.io/">YoungGwon's IT Tech Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-html" role="menuitem"><a href="/tag/html/">HTML</a></li>
    <li class="nav-css" role="menuitem"><a href="/tag/css/">CSS</a></li>
    <li class="nav-js" role="menuitem"><a href="/tag/javascript/">JS</a></li>
    <li class="nav-typescript" role="menuitem"><a href="/tag/typescript/">TS</a></li>
    <li class="nav-react" role="menuitem"><a href="/tag/react/">React</a></li>
    <li class="nav-nextjs" role="menuitem"><a href="/tag/nextjs/">NextJS</a></li>
    <li class="nav-git" role="menuitem"><a href="/tag/git/">Git</a></li>
    <li class="nav-etc" role="menuitem"><a href="/tag/etc/">Etc</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "javascript-symbol": {
        "title": "Symbol 자료형?",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 Symbol이라는 자료형에 대해서 알아보겠습니다.SymbolES6에서 Symbol이라는 자료형이 추가되었는데 이 자료형을 만드는 법을 알아보겠습니다.const symbol = Symbol('Symbol 입니다.');그냥 Symbol()을 사용하여 만들고 괄호안에 이 Symbol의 설명을 써주면 됩니다.Symbol은 어디에 사용되나?Symbol은 도대체 어디에 사용되는 걸까요?Symbol은 Object에 숨기고 싶은 비밀의 key값을 주고싶을 때 사용합니다.원래 Object의 key값은 문자만 입력할 수 있었습니다. 하지만 문자가 아닌 것을 입력하더라도 문자로 바뀌며, ES6부터 Symbol도 key값으로 할 수 있게 되었습니다.const client1 = { name : 'kim', age : 26 };let phoneNumber = Symbol('핸드폰 번호');client1.[phoneNumber] = '010-0000-0000';client1이라는 object가 있을 때 핸드폰 번호를 직접적으로 넣지않고 숨겨서 등록하고 싶습니다.이럴 경우 Symbol을 이용할 수 있습니다. phoneNumber라는 변수에 Symbol을 생성하여 넣고, 위의 예시처럼 []를 이용하여 client1에 등록하면 Symbol의 형태로 Object에 등록할 수 있습니다.실제로 client1을 출력해보면 Symbol의 형태로 등록이 되어있습니다.Symbol은 for문에 등장하지 않습니다. 즉 Symbol로 등록한 것은 반복문을 돌릴 때 감지하지 못합니다.Symbol을 직접적으로 등록하는 방법const client1 = { name : 'kim', age : 26, [phoneNumber] : '010-0000-0000' };Symbol은 그냥 Object안에서 직접 등록할 수도 있는데, 역시 []를 이용하여 등록하면 됩니다.Symbol의 특징const a = Symbol('심볼');const b = Symbol('심볼');console.log(a == b);console.log(a === b);Symbol을 만들 때 괄호안에 Symbol의 설명을 쓰는데, 이 설명이 같다고 하더라도 위와 같이 a와 b는 서로 같은 Symbol이 아닙니다.실제로 출력해보면 false가 출력됩니다.const a = Symbol.for('심볼');const b = Symbol.for('심볼');console.log(a == b);console.log(a === b);Symbol옆에 for()를 붙여서 Symbol을 만들 수도 있는데, 이 Symbol들은 전역 Symbol이 됩니다.이러한 경우 a와 b는 서로 같은 Symbol이며, true가 출력됩니다.End.",
        "url": "/javascript-symbol"
    }
    ,
    
    "javascript-asyncawait": {
        "title": "ES8 - async / await",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 ES8에서 추가된 async / await에 대해서 정리해보겠습니다.asyncPromise를 사용하기 어렵게 느껴진다면 async와 await를 사용할 수 있습니다.async와 await은 각각 Promise, then을 조금 더 쉽게 만들어 줍니다.Promise는 원래 new Promise()로 생성하고 그 안에 함수를 통해 성공과 실패를 판정합니다.async를 함수 앞에 붙이면 이 함수를 실행할 때, Promise 인스턴스가 그 자리에 남게됩니다.따라서 뒤에 then()을 붙일 수가 있습니다.async function sum() {    return 2 + 2;}sum().then((result) =&gt; {    console.log('결과 : ' + result);})sum 함수에 async가 붙어있고, 이 sum 함수를 실행한 자리에는 Promise 인스턴스가 남게되어 then()을 사용할 수 있습니다.위의 예시의 결과는 ‘결과 : 4’가 되겠네요.await.then()을 사용할 수 도 있지만 이것도 복잡하다고 느낄 수 있습니다. 다른 방법으로 await 키워드를 사용하는 것입니다.async function sum(){    const calculation = new Promise((성공, 실패)=&gt;{        const result = 1 + 1;        성공(result);    });    const result = await calculation;    console.log(result);}sum();await은 async 키워드를 사용한 함수 안에서 사용할 수 있으며, await은 프로미스.then() 대신에 쓸 수 있는 대체품 느낌입니다.await은 Promise를 기다린 다음에 완료 후, 그 결과를 변수에 담습니다. 위의 예시에서 calculation이라는 프로미스가 끝날 때 까지 기다린 후, 그 결과값인 2를 result라는 변수에 담게됩니다.결과적으로 2가 출력되겠네요.await은 Promise를 기다리는 데, Promise가 실패할 경우에는 에러가 발생하고, 코드를 멈추는 특징이 있습니다. 그래서 Promise가 실패하더라도, 코드가 멈추지 않고 계속 이어가려면 try-catch문을 사용하여 예외처리를 해주어야합니다.async function sum() {    const calculation = new Promise((resolve, reject) =&gt; {        reject();    })    try { const result = await calculation; }    catch {        // 이곳에 calculation 프로미스가 실패했을 경우에 실행할 코드를 작성하기.    }}정리하자면 async/ await은 Promise와 then을 조금 더 쉽게 만들어줄 수 있습니다. 물론 무조건 async / await이 더 간결하고 사용하기 쉽다라는 것은 아니며, 상황에 따라서 사용하는 것이 좋을 것 같습니다.End.",
        "url": "/javascript-asyncawait"
    }
    ,
    
    "javascript-promise1": {
        "title": "프로미스(Promise)에 대해서",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 Promise에 대해서 정리해보겠습니다.Promise프로미스는 다음과 같이 new 키워드를 통해서 만들 수 있습니다.const promise = new Promise();이 promise옆에 .then()을 붙일 수 있습니다. 이것에 대해서 더 알아보도록 하겠습니다.const promise = new Promise();promise    .then(() =&gt; {        console.log('성공!');    })    .catch(() =&gt; {        console.log('실패!');    })프로미스 옆에 .then()이나 .catch(), 그리고 .finally()를 붙여서 코드를 작성할 수 있습니다. 각각의 의미는 다음과 같습니다.  then() 안에는 어떤 코드가 성공했을 경우 실행할 함수를 넣습니다. 성공 시에 실행되는 코드를 담으면 됩니다.  catch() 안에는 어떤 코드가 실패했을 경우 실행할 함수를 넣습니다. 실패 시에 실행할 코드를 담습니다.  finally()는 성공이나 실패 여부에 상관 없이 무조건 실행되는 코드를 담습니다.자, ‘성공시에는 이러한 코드, 실패시에는 이러한 코드를 실행시켜주는 구나.’ 라는 것은 알겠는데 성공할 지 실패할 지 어떻게 판단할까요?바로 Promise가 성공과 실패를 판정하는 역할을 합니다.const promise = new Promise((resolve, reject) =&gt; {    // 이 곳에 resolve(); 또는 reject();를 쓰면 각각 성공과 실패가 판정됩니다.});promise    .then(() =&gt; {        console.log('성공!');    })    .catch(() =&gt; {        console.log('실패!');    })위의 코드에서 new Promise()안에 함수를 넣을 수 있고, 파라미터는 resolve(성공), reject(실패)를 가지게 됩니다. 이후 resolve()를 써주면 성공, reject()를 쓰면 실패가 판정됩니다.간단한 활용 예시를 더 알아보겠습니다.const promise = new Promise((resolve, reject) =&gt; {    let a = 2 + 2;    if (a &gt; 3) resolve(a);    else reject(a);});promise    .then(() =&gt; {        console.log('성공!');    })    .catch(() =&gt; {        console.log('실패!');    })Promise안에서 a 라는 변수에 2 + 2 연산을 하고 저장하였습니다. a의 값은 4가 될 것입니다.그 밑에 if를 사용하여 연산값인 a가 3 이상일 경우 resolve(a); 그렇지 않다면 reject(a);를 하게 만들었습니다.a의 값은 4고, 3보다 크기 때문에 resolve(a);가 실행되어 ‘성공’이 판정됩니다.따라서 then()안에서 정의했듯, 콘솔에 ‘성공!’ 이라는 메세지가 출력되게됩니다.정리하자면, Promise는 성공/실패를 판정해주는 데 사용하며, then()과 catch()를 통해서 이후의 코드를 실행해주는 일종의 디자인 패턴입니다.Promise의 상태Promise는 상태라는 것을 가집니다.new Promise()로 생성된 변수를 출력해보면 현재 ‘상태’를 알 수 있습니다.  성공/실패 판정 전에는  상태 (대기)  성공 이후에는  상태 (성공)  실패 이후에는  상태 (실패)실제로 Promise를 출력해보면 현재 상태를 알수 있습니다. 정리하면 프로미스 오브젝트는 3가지 상태(pending, resolved, rejected)를 가집니다. 참고로 성공을 실패나 대기 상태로 되돌릴 수는 없습니다.End.",
        "url": "/javascript-Promise1"
    }
    ,
    
    "javascript-optionalchaining": {
        "title": "Optional Chaining (?.)",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 ?. (Optional Chaining)에 대해서 알아보겠습니다.Optional Chaining(?.)const person = {    name : 'kim',    age : 26,    phoneNumber : '010-1234-5678'}console.log(person.name);person이라는 object가 있습니다. 여기서 ‘person.name’을 찾고싶습니다.콘솔에는 당연히 ‘kim’이 출력될 것입니다. const person = {    name : 'kim',    age : 26,    phoneNumber : '010-1234-5678'}console.log(person?.name);Optional Chaining은 위처럼 . 옆에 ?를 붙이는 것인데, 위의 ‘person?.name’은 무슨 의미일까요?person이 null이거나 undefined이면 undefined로 하라는 의미입니다. 어떤 경우에 사용을 하면 좋을까요?var user = {    name : {last : 'kim', first : 'subin'},    age : 26,    phoneNumber : '010-1234-5678'}console.log(user.name1?.first);위와 같이 object가 중첩되어있는 경우에 사용하면 좋습니다.만약 자료가 깊이 있고 자료를 찾을 때 실수를 해서 잘못찾는 경우에 에러가 날 수 있습니다.null이거나 undefined인 경우에 . 을 이용해서 자료를 찾으면 에러를 발생시키기 때문입니다.실제 서비스에서 이런 에러가 발생할 경우에는 위험할 수 있고 에러발생시 다른 코드가 정상적으로 동작하지 않을 수 있습니다.그리고 보통은 if문을 이용해서 undefined이거나 null일 경우에 처리를 해주는 경우가 있는데 ?. 을 사용하면 에러를 발생시키지 않아서 유용합니다.물론 근본적으로 에러를 해결해주는 것은 아니며 에러가 발생하지 않도록 숨겨주는 역할을 하는 것이 ?. 입니다.End.",
        "url": "/javascript-optionalChaining"
    }
    ,
    
    "javascript-module": {
        "title": "import / export 를 사용한 모듈식 개발방법",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 import / export 를 사용한 모듈식 개발방법에 대해서 정리해보겠습니다.ModuleJS 코드를 작성하다보면 코드가 길어집니다. 그래서 한 파일에 코드가 길어질 때 파일을 쪼개서 모듈식으로 개발합니다.&lt;script src='feature.js'&gt;&lt;/script&gt;index.html 파일에 feature.js라는 파일을 첨부할 때 위와 같이 보통 작성합니다.&lt;script type='module'&gt;&lt;/script&gt;그런데 이렇게 가져오는 방법도 있습니다.type=’module’ 을 붙여주는 것인데, 이렇게하면 특정 파일안에 있는 변수를 가져올 수 있습니다.아래 예시를 보겠습니다.// feature.jsconst name = 'kim';export default name;&lt;!-- index.html --&gt;&lt;script type='module'&gt;    import name from 'feature.js';&lt;/script&gt;feature.js 안에 있는 name이라는 변수에 ‘export default’를 붙이면, 위와 같이 ‘import 변수명 from 경로’를 작성해주어 변수를 가져올 수 있습니다.여기서 export default가 붙은 변수를 가져올 때 import 다음 ‘변수명’은 새롭게 작명이 가능합니다.주의해야할 점은 export default는 파일 안에서 한번만 쓸 수 있습니다.그러면 가져올 변수가 많으면 어떻게 할까요?// feature.jsconst name = 'kim';const age = 26;export {name, age};&lt;!-- index.html --&gt;&lt;script type='module'&gt;    import {name, age} from 'feature.js';&lt;/script&gt;위와 같이 ‘export’만 붙이되, {}로 감싸주어야합니다. import하는 파일안에서도 {}로 변수를 감싸주어야합니다.as로 변수이름 새롭게 지어주기// feature.jsconst name = 'kim';const age = 26;const number = 100;export {name, age};export default number;&lt;!-- index.html --&gt;&lt;script type='module'&gt;    import number as 숫자, {name as 이름, age as 나이} from 'feature.js';&lt;/script&gt;위와 같이 ‘as 변수명’의 형태로 써주면 새롭게 변수명을 지어줄 수 있습니다.End.",
        "url": "/javascript-module"
    }
    ,
    
    "javascript-defaultparameter": {
        "title": "default 파라미터 알아보기",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 default 파라미터에 대해 정리해보겠습니다.사실 이 내용은 너무 간단한 내용입니다.default 파라미터function sum(a, b) {    console.log(a + b);}예시에서 sum 이라는 함수를 정의하였습니다. a와 b의 두개의 파라미터를 받고 있고 두 값을 더하여 콘솔에 출력해주는 함수입니다.sum(1,2);함수를 만들어서 테스트해보니 3이라는 결과가 잘 나옵니다.그런데 만약 실수로 인자를 하나 넣지 않는다면 어떻게 될까요?sum(1);이렇게 하나의 숫자를 넣고 실행했더니 NaN이 나왔습니다. 이렇게 값을 하나 빼먹었는데도 에러가 발생하지 않고 있습니다.이런 경우 파라미터의 default값을 지정할 수 있습니다.function sum(a, b = 0) {    console.log(a + b);}파라미터 옆에 등호를 붙여서 0이라는 값을 작성해주면 해당 파라미터의 값이 없을 경우 기본값으로 0을 대입해줄 수 있습니다.그래서 sum(1); 과 같이 함수를 실행해도 1 + 0으로 1이 출력되게 할 수 있습니다.default 파라미터는 기본값을 지정할 때 일반적인 값을 지정해줄 수도 있지만, 연산이나 함수도 지정가능합니다.function sum(a, b = a * a) {    console.log(a + b);}sum(2);b의 기본값을 a * a로 해줬더니, sum(2)의 결과가 2 + 2*2 로 6이 출력되었습니다.End.",
        "url": "/javascript-defaultParameter"
    }
    ,
    
    "javascript-destructuring": {
        "title": "ES6 Destructuring Syntax",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 ES6의 Destructuring 에 대해서 정리해보겠습니다.Destructuringconst arr = [1,2,3];const a = arr[0];const b = arr[1];const c = arr[2];arr라는 array가 있고 1,2,3 이라는 값을 가지고 있습니다. 이 값들을 각각 a, b, c에 저장하고 싶습니다. 그러면… 위 처럼 인덱스를 이용해서 값을 저장하면 됩니다. 그런데 이 방법이 귀찮을 수 있습니다. 그래서 추가된 것이 Destructuring입니다.const arr = [1,2,3];const [a, b, c] = [1,2,3];// const [a, b, c] = arr;우측에 array를 쓰고 좌측에 우측과 대응하여 위와 같이 작성하면 됩니다.그러면 a, b, c는 각각 1, 2, 3이 됩니다. 더 편하지 않나요?default값 지정하기const [a,b,c] = [1,2];위의 예시처럼 개수가 서로 맞지 않으면 어떻게 될까요? a와 b에는 각각 1, 2가 저장되지만 c는 undefined가 됩니다.그래서 c에 기본값(default 값)을 지정해놓을 수 있습니다.const [a,b,c = 10] = [1,2];이렇게 ‘c = 10’ 으로 지정해두면 c에 대응되는 것이 없을 때 기본값으로 10이 됩니다.Object에서도 가능하다.const { name, age } = { name : 'Lee', age : 26 };Object에서도 Destructuring 문법을 적용할 수 있습니다. name은 ‘Lee’가 되고, age는 26 이됩니다. 여기서는 각각의 key값으로 지정해야합니다.const { name : 이름, age : 나이 } = { name : 'Lee', age : 26 };key값으로 변수명을 지정해야하지만, 위와 같이 ‘이름’, ‘나이’ 처럼 다른 변수명을 써주면 변수명을 바꿀 수 있습니다.(이름 = Lee, 나이 = 26)변수를 오브젝트에 넣기const name = 'Lee';const age = 26;const obj = { name : name, age : age }obj에 위의 name, age 변수를 각각 저장하려면 위와 같이 작성하면됩니다.// const obj = { name : name, age : age } 처럼 key와 value가 동일한 이름이면 축약할 수 있다.const obj = { name, age };그런데 key와 value가 동일한 이름이면 축약하여 위처럼 작성할 수 있습니다.함수의 parameter에도 적용가능하다.function info( { name, age } ) {    console.log(name, age);}const object = { name : 'Lee', age : 26 };info(object);함수의 파라미터 자리에도 위와 같이 적용할 수 있습니다. (Array형태도 가능)함수를 실행했을 때 콘솔창에 name과 age값이 각각 ‘Lee’, 26이 출력될 것 입니다.End.",
        "url": "/javascript-Destructuring"
    }
    ,
    
    "javascript-classconstructor": {
        "title": "JS class 만들기",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 class 키워드를 사용하여 클래스를 만드는 방법에 대해서 알아보겠습니다.Classclass Animal {    constructor(type) {        this.type = type;    }}const dog1 = new Animal('dog');console.log(dog1);위의 예시는 간단하게 동물 클래스를 만든 것입니다. ‘class’를 붙여서 정의하는데, constructor를 사용하면 생성되는 Object의 기본값들을 초기화할 수 있습니다.Animal을 이용하여 dog1 오브젝트를 생성하였습니다.또한 클래스안에 함수 역시 추가할 수 있습니다.// 1번 class Person {    constructor(name) {        this.name = name;        this.sayHi = function() {            console.log('Hi');        }    }    }const person = new Person('Kim');// 2번class Person {    constructor(name) {        this.name = name;    }    sayHi() {        console.log('Hi');    }}const person = new Person('Kim');1번의 경우에는 constructor 내부에 함수를 추가했습니다. 이 경우는 함수를 직접적으로 자식이 값을 물려받습니다.2번의 경우에는 constructor 밖에 함수를 추가했습니다. 이 경우는 함수가 Person의 prototype에 추가됩니다. (자식의 부모의 prototype에 추가)상속하나의 클래스를 상속하여 다른 클래스를 만들 수 있습니다. 바로 ‘extends’ 키워드를 사용하면 됩니다.class Animal {    constructor(type) {        this.type = type;    }}class Pets extends Animal {    constructor(type, age) {        super(type); // Animal의 constructor안의 값들을 그대로 가져온다고 보면된다.        this.age = age;    }}const choco = new Pets('dog', 2);console.log(choco);Animal 클래스를 상속하여 Pets 라는 클래스를 만들고 choco라는 오브젝트를 만든 것입니다.위처럼 ‘extends’ 다음에 상속하고 싶은 대상을 쓰면 됩니다.  그리고 Pets의 constructor안에 super()를 써줘야 Animal의 constructor안의 값들을 그대로 가져옵니다.super안의 파라미터는 부모의 constructor에 들어가는 파라미터랑 동일한 값이 들어갑니다.End.",
        "url": "/javascript-ClassConstructor"
    }
    ,
    
    "javascript-spreadoperator": {
        "title": "Spread Operator(...)?",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 Spread Operator(스프레드 연산자)에 대해서 정리해보도록 하겠습니다.… 의 활용…은 상황에 따라 2가지로 활용될 수 있습니다.  Rest parameter  Spread Operator첫번째로 Rest 파라미터로 사용되는 경우입니다. 이 경우는 함수 파라미터에 ‘…‘이 붙는 경우에 사용됩니다.그 나머지 경우는 Spread Operator로 사용됩니다. 이번 글에서는 Spread Operator만 다뤄볼 것입니다.Spread Operatorconst arr = [1,2,3];console.log(...arr);위처럼 ‘…‘을 붙여서 사용하면 Array안의 요소가 모두 출력됩니다. 괄호가 제거된다고 생각해도 무방할 것 같습니다.const word = 'apple';console.log(...word) ;문자에서도 …을 앞에 붙여줄 수 있는데, 이렇게 되면 한글자씩 해체가 됩니다. (a p p l e)활용보통 Spread Operator는 Array나 Object를 합치거나 그대로 복사하고 싶을 때 사용합니다.const a = [1,2];const b = [3,4,5];const sum = [...a, ...b];console.log(sum);Array a와 Array b가 있을 때, sum이라는 새로운 Array를 위처럼 만들 수 있습니다. 출력해보면 Array sum은 ‘[1,2,3,4,5]’ 가 출력이 됩니다. 이렇게 두 개를 합치는 경우에 사용할 수 있고…const arr1 = ['a','b','c'];const arr2 = [...arr1];이렇게 그대로 복사하는 경우에도 사용할 수 있습니다. 그냥 arr2 = arr1하면 되는 거 아닌가? 할 수 있지만, Array나 Object는 reference data type이기 때문에arr1이 변경되었을 때 arr2도 같이 변경되기 때문에 직접적으로 복사하면 영향을 받습니다.마지막으로 함수 파라미터를 넣을 때 사용하기도 합니다.function sum(a,b,c,d) {    console.log(a + b + c + d);}const arr = [1,2,3,4];sum(arr[0],arr[1],arr[2],arr[3]);sum 함수에는 각 Array의 값들이 들어가고 있습니다. 그런데 만약 Array의 값들이 엄청 많다면 일일히 인자로 넣는 것는 힘들고 귀찮습니다.그래서 다음과 같이 간단하게 사용할 수 있습니다.sum(...arr);이렇게 Spread Operator를 사용하면 간편해집니다.End.",
        "url": "/javascript-SpreadOperator"
    }
    ,
    
    "javascript-aboutthis": {
        "title": "this의 여러가지 의미",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글은 this에 대해서 정리해보겠습니다.자바스크립트에서 this는 상황별로 의미가 조금씩 다릅니다.1. 그냥 this를 사용하거나 일반 함수 내에서 의미// 그냥 this를 콘솔에 출력해보기console.log(this)// 일반적인 함수 안에서 this를 출력해보기function test(){    console.log(this);}test();이 경우에는 둘다 window라는 object가 출력됩니다. window는 자바스크립트의 기본 함수들이 모두 모여있는 전역 객체입니다.여기서 주의할 점은 strict mode인 상태에서 함수내에 this를 사용할 경우엔 window가 아닌 undefined가 출력됩니다.2. object안의 메소드에서 this를 사용할 시const person = {    name : 'Son',    info : function() {        console.log(this);    }}person.info();위의 예시처럼 person이라는 object안에 info 라는 메소드가 있고, 그안에서 this를 출력하는 코드를 작성해보았습니다. 이 경우의 this는 이 메소드를 가지고 있는 object를 의미합니다.3. 인스턴스의 의미클래스로부터 생성되는 오브젝트, 즉 인스턴스를 의미하기도 합니다.4. 이벤트리스너에서 thisdocument.getElementById('button').addEventListener('click', function() {    console.log(this);})‘button’이라는 id값을 가진 버튼이 있다고 가정하고, 이 버튼을 가져와서 이벤트를 추가하는 상황입니다.2번째 인자로 콜백함수가 들어가고 그 안에서 this를 출력해보면 이벤트가 동작하는 대상이 출력됩니다. 즉, 버튼이 출력이 됩니다.이는 event.currentTarget과 동일합니다.주의할 점은 function키워드가 아니라 화살표함수를 사용한 경우 this는 다른 값이 나옵니다. 이 경우는 외부 this를 그대로 사용합니다.화살표함수를 사용할 때와 그냥 function 키워드로 사용할 떄와의 차이를 구분해서 잘 사용해야겠습니다.End.",
        "url": "/javascript-aboutThis"
    }
    ,
    
    "etc-webstorage": {
        "title": "쿠키와 웹스토리지에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해이번 글에서는 쿠키와 웹스토리지(로컬스토리지, 세션스토리지)에 대해서 정리해보겠습니다.배경HTTP는 클라이언트와 서버간에 소통을 할 때 지켜야할 통신규약입니다. 먼저 클라이언트가 서버에게 요청을 보내고 서버는 그에 맞는 응답을 보낸 후 접속을 종료합니다.통신이 끝나면 상태정보를 유지하지 않는 특징이 있습니다. 예를 들어 인증에 필요한 상태정보를 말이죠. 그래서 통신을 할 때마다 새로 연결을 해주어야 합니다. 물론 지속적으로 통신을 연결하지 않는 것은 자원을 낭비하지 않는 장점이 있을 수 있지만, 통신을 할 때마다 인증을 해주어야 합니다.이런 경우 반복적인 인증작업이 필요한데 이런 면에서 비효율적이게 됩니다. 유저도 불편하겠죠. 그래서 이런 정보를 따로 저장해두기위한 것이 브라우저 저장소입니다. 브라우저 저장소에는 쿠키와 웹 스토리지가 있습니다.쿠키쿠키는 서버가 클라이언트에게 전송하는 작은 데이터 파일이며 이름, 값, 도메인정보, 경로정보, 만료일 등으로 구성됩니다.쿠키특징은 다음과 같은 것들이 있습니다.  모든브라우저에서 지원함.  매번 서버에 전송되고 저장 용량이 작음. (하나의 쿠키는 4KB까지 저장 가능)  보안에 취약함.  클라이언트에 총 300개의 쿠키를 저장할 수 있고 하나의 도메인 당 20개의 쿠키를 가질 수 있음.웹 스토리지HTML5부터 쿠키의 단점을 보완하여 등장한 것이 웹 스토리지(Web Storage)가 주로 사용됩니다.웹 스토리지는 쿠키와 기능은 유사하지만, 서버로 전송되지 않고 클라이언트에 저장합니다. 데이터를 저장할 때는 key와 value값으로 저장합니다. 웹 스토리지는 데이터의 지속성에 따라 Local Storage(로컬 스토리지)와 Session Storage(세션 스토리지)로 나눌 수 있습니다.차이점은 다음과 같습니다.  Local Storage(로컬 스토리지) : 브라우저 자체에 반영구적으로 데이터를 저장하며 브라우저를 닫아도 데이터가 유지되는 특징  Session Storage(세션 스토리지) : 윈도우나 브라우저 탭을 닫을 경우에 데이터가 삭제됩니다.무엇을 사용하는게 좋은가?이는 각 브라우저 저장소의 특징에 맞게 상황에 따라 사용합니다.예를 들어 비로그인 유저 장바구니 기능은 세션스토리지, 자동로그인기능은 로컬스토리지, “일주일간 다시 보지 않기” 창 같은 경우는 쿠키를 사용하면 좋을 것 같습니다.End.",
        "url": "/etc-webstorage"
    }
    ,
    
    "javascript-settimeout": {
        "title": "setTimeout과 setInterval 요약",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?setTimeoutsetTimeout은 특정 시간이후에 함수를 실행시켜줍니다.const timerId = setTimeout(() =&gt; console.log('setTimeout'), 2000);// 종료 시에clearTimeout(timerId)위의 예시는 2000(2초)뒤에 콘솔에 ‘setTimeout’ 이라는 문자열을 출력해줍니다.setIntervalsetInterval은 특정 시간동안 반복해서 함수를 실행시켜줍니다.setInterval(() =&gt; console.log('setInterval'), 3000)// 종료 시에clearInterval(timerId)위의 예시는 3000(3초)마다 콘솔에 ‘setInterval’ 이라는 문자열을 출력합니다.End.",
        "url": "/javascript-setTimeout"
    }
    ,
    
    "css-marginpadding": {
        "title": "CSS margin과 padding의 차이",
            "author": "ykkim97",
            "category": "",
            "content": "CSS는 다음과 같이 구성되어 있습니다.     CSS의 의미와 적용방법    block과 inline의 차이점    em과 rem의 차이    Sass - CSS 전처리기    CSS margin과 padding의 차이오늘은 CSS에서 margin(마진)과 paddin(패딩)의 차이에 대해서 정리해보겠습니다.margin과 padding제가 간단하게 그린 그림입니다.content는 말 그대로 컨텐츠, 내용이고 border는 그 내용을 감싸는 테두리를 의미합니다. 이 border를 기준으로 바깥쪽 여백을 margin이라고 하고, 안쪽 여백을 padding이라고 하는 것입니다.margin과 padding 값 설정하기css코드에서 margin과 padding값을 주고 싶을 때 어떻게 할까요?예시를 통해서 쉽게 알아보겠습니다.  margin : 10px 1px 1px 5px;  margin : 10px 3px 1px;  margin : 5px;      1번 예시는 4개의 값을 margin값으로 주었습니다. 이는 왼쪽부터 상 ➡ 우 ➡ 하 ➡ 좌 순으로 값을 지정합니다. 시계 반대 방향이라고 생각하면 됩니다.    2번 예시는 3개의 값을 주었는데, 상 10px, 좌우 3px, 하 1px을 의미합니다.  3번 예시는 상우하좌 모두 동일하게 5px로 지정된 것입니다.End.",
        "url": "/css-marginPadding"
    }
    ,
    
    "javascript-nullundefined": {
        "title": "null과 undefined의 차이 간단정리",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?이번 글에서는 null과 undefined의 차이에 대해서 간단히 알아보겠습니다.언뜻봐서는 비슷해보일 수 있지만 명확한 차이가 있습니다.null vs undefinednull은 어떤 값이 명시적으로 비어져있음을 의미합니다.반면 undefined는 변수가 선언이 되었지만 값이 할당되지 않은 경우를 의미합니다.선언만 하고 값을 할당하지 않거나, return값이 없는 함수, 선언되지 않은 객체의 속성의 경우 undefined를 반환합니다.주의할만한 것들typeof null          // \"object\" =&gt; 사실 null의 타입은 null이 맞다. 초기버전의 버그이다.typeof undefined     // \"undefined\"null === undefined   // falsenull == undefined   // truenull === null        // truenull == null         // true!null                // trueisNaN(1 + null)      // falseisNaN(1 + undefined) // true  출처 : MDNEnd.",
        "url": "/javascript-nullUndefined"
    }
    ,
    
    "html-semantictag": {
        "title": "시맨틱 태그?",
            "author": "ykkim97",
            "category": "",
            "content": "HTML은 다음과 같이 구성되어 있습니다.     웹의 기본중의 기본! HTML에 대해서 알아보자    HTML 기본 태그들    DOCTYPE의 의미?    시맨틱 태그?이번 글에서는 시맨틱태그(Semantic Tag)에 대해서 정리해보겠습니다.시맨틱 태그?시맨틱 태그라는 것은 의미를 가진 태그라는 의미입니다. 예를 들어, “&lt;h1&gt;“태그는 제목태그라는 의미를 가지고 있는 것이고, “&lt;header&gt;“태그는 헤더의 의미를 가지고 있는 것입니다.사실 이런 태그를 사용하지 않고도 “&lt;div&gt;“태그만으로 영역을 나누어서 스타일링해도 충분히 웹사이트를 만들 수 있습니다. 그러면 왜 시맨틱 태그를 사용해야 할까요?시맨틱태그는 일단 개발자가 더 편하게 웹사이트를 유지보수하는데 도움을 줍니다. 단순하게 “&lt;div&gt;“태그 투성이인 것보다, 태그에 의미를 가지고 있다면 한눈에 파악하기도 좋을 것입니다.그리고 SEO(검색 엔진 최적화)에 도움을 줍니다.일반적인 구조  “&lt;header&gt;” : 웹사이트 페이지의 제목이나 소개, 로고와 같은 것을 포함합니다.  “&lt;nav&gt;” : “&lt;header&gt;“안에 만약 여러가지 메뉴가 있을 때 보통 “&lt;nav&gt;“를 사용합니다.  “&lt;main&gt;” : 메인 컨텐츠가 담기는 곳에 사용합니다.  “&lt;aside&gt;” : main안에서 직접적으로 관련이 없는 경우에 사용합니다.  “&lt;section&gt;, &lt;article&gt;” : “&lt;section&gt;, &lt;article&gt;“을 사용하여 main안의 컨텐츠를 구분합니다.  “&lt;footer&gt;” : 웹사이트의 맨 밑부분의 부가적인 정보 등에 사용합니다.&lt;section&gt;과 &lt;article&gt;의 차이?article태그는 신문기사에서 기사 하나하나를 의미합니다. 그 자체로 독립적입니다.그리고 section은 서로 연관된 부분을 묶어줄 때 보통 사용합니다. 한개의 페이지에 여러 내용들이 있다면 하나의 section안에 여러 article들이 있을 것입니다.End.",
        "url": "/html-semanticTag"
    }
    ,
    
    "git-gitflow": {
        "title": "Git Flow 전략에 대해(브랜치 관리 전략)",
            "author": "ykkim97",
            "category": "",
            "content": "Git은 다음과 같이 구성되어 있습니다.     Github Label별 의미    git add , commit, 그리고 staging    Git Flow 전략에 대해(브랜치 관리 전략)개발한 코드를 git으로 관리할 때 그냥 main(master)브랜치에 관리하는 것은 좋지 않을 수 있습니다. 특히나 규모가 큰 프로젝트에서 말이죠.물론 상황에 따라서 다를 수 있습니다.오늘은 많이 사용하는 브랜치 전략인 git Flow 전략을 정리해보겠습니다.Git Flow 전략제가 그린 것을 보고 정리해보겠습니다.일단 현재 배포중인 최종본은 Main(Master)브랜치에서 관리합니다.이후에 개발을 할 때 git flow 전략은 이 Main 브랜치에서 develop 브랜치를 하나 생성하여 개발을 진행합니다.   이후 신규 기능을 개발할 때, 이 develop브랜치에서 feature브랜치를 추가로 생성합니다. 만약 로그인 기능을 개발하는 브랜치라면 “feature/login” 과 같은 이름으로 브랜치를 생성합니다.기능 개발을 완료하고 정상적으로 작동하는지 검토한 후 에 develop브랜치와 이 브랜치를 병합합니다.  새로운 기능이 추가된 develop브랜치를 바로 Main브랜치와 합치기 전에 release 브랜치를 생성하는데, 이것은 이번 출시 버전을 준비하는 브랜치로, 배포전 최종적으로 확인하기위한 브랜치입니다.  이후 최종테스트를 마친 후에, Main으로 배포하게 됩니다. 물론 release 브랜치는 Main브랜치 뿐만 아니라 develop브랜치와도 병합합니다.  배포 버전에서 갑작스러운 버그가 발생하여 급하게 수정해야하는 경우도 있을 것입니다. 이런 경우에는 Main브랜치에서 바로 hotfix라는 브랜치를 생성하여 버그를 수정한 후 바로 Main과 병합하여 배포하게 됩니다. (develop브랜치와도 병합)장점이 git flow 전략의 장점이 뭘까요?신중하게 관리하는 전략이기 때문에 안정적인 배포가 가능하다는 점입니다.정리하기크게 5가지 브랜치로 관리한다.  (main)master : 배포중인 브랜치  develop : 다음 출시 버전 개발하는 브랜치  feature : 기능을 개발하는 브랜치  release : 이번 출시 버전 준비하는 브랜치  hotfix : 출시중인 버전에서 발생한 버그를 수정하는 브랜치End.",
        "url": "/git-gitflow"
    }
    ,
    
    "javascript-functionexpression": {
        "title": "함수선언식과 함수표현식",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?오늘은 함수선언식과 함수표현식에 대해서 간단히 정리해보겠습니다.함수선언식함수선언식이란 “function” 키워드를 사용해서 함수를 정의하는 방법입니다.function hello() {    console.log('hello');}hello();그냥 우리가 기본적으로 알고있는 방식입니다.함수 표현식함수표현식은 별도의 변수에 함수를 할당하는 방식입니다.자바스크립트에서는 함수도 하나의 값으로 취급될 수 있습니다.const hello = function () {    console.log('hello');}위처럼 hello라는 변수에 함수를 할당합니다.const hello = () =&gt; console.log('hello');보통은 익명함수를 사용하며 화살표함수를 많이 사용합니다.차이점함수선언식과 함수표현식의 차이점은 무엇일까요?이는 호이스팅에 영향을 받는지에 차이가 있습니다.함수선언식은 호이스팅에 영향을 받고, 함수표현식은 호이스팅에 영향을 받지 않습니다.hello();function hello() {    console.log('hello');}hello함수를 호출하고 이후 함수선언식을 통해서 hello함수를 선언하면 호이스팅이 되기 때문에 에러가 발생하지 않고 정상적으로 실행됩니다.hello();const hello = () =&gt; {    console.log('hello');}반면 위처럼 함수표현식형태로 했을 경우 호이스팅이 되지 않기 떄문에 에러가 발생하게 됩니다.정리  함수선언식이란 “function” 키워드를 사용해서 함수를 정의하는 방법입니다.  함수표현식은 별도의 변수에 함수를 할당하는 방식입니다.  함수선언식은 호이스팅에 영향을 받고, 함수표현식은 호이스팅에 영향을 받지 않는다.End.",
        "url": "/javascript-functionExpression"
    }
    ,
    
    "css-sass": {
        "title": "Sass - CSS 전처리기",
            "author": "ykkim97",
            "category": "",
            "content": "CSS는 다음과 같이 구성되어 있습니다.     CSS의 의미와 적용방법    block과 inline의 차이점    em과 rem의 차이    Sass - CSS 전처리기    CSS margin과 padding의 차이오늘은 Sass가 뭔지 정리해보겠습니다.CSS는 스타일을 넣어주는 역할을 합니다. 개발을 하다보면 코드가 길어지게되고 그만큼 CSS코드도 많아집니다.또한 스타일지정이 반복되는 경우도 많고 관리하기도 힘들어집니다. 이런 문제들을 해결할 수 있는 CSS Preprocessor(전처리기)라는 것이 있습니다. 그중에 하나가 Sass입니다. Sass는 CSS와 동일하게 코드를 작성할 수 있는데 추가적으로 프로그래밍적인 문법이 추가된 것입니다.예를 들어서 조건문이나 반복문, 변수 같은 것을 쓸 수 있는 것입니다.환경세팅VSCode 기준으로 익스텐션에서 “Live Sass Compiler”를 검색해서 설치해주시면 됩니다.이후에는 일반 css사용하는 것과 똑같은데 .css확장자가 아니라 .scss라는 확장자로 파일을 만들어서 코드를 작성합니다. 물론 브라우저는 이 css파일만 읽을 수 있습니다. 그래서 scss파일을 css로 바꿔줘야하기 때문에 “Live Sass Compiler” 익스텐션을 설치한 것입니다. 참고로 .sass라는 확장자로 파일을 만들 수도 있는데 .sass파일은 css를 작성할 때 중괄호를 쓰지 않는다는 점이 다르고 거의 차이가 없습니다. 개인적으로는 중괄호를 쓰는게 더 편하기 때문에 .scss확장자를 사용하는게 편하다고 봅니다.scss파일에 코드를 작성했다면 vscode 하단에 다음과 같이 “Watch Sass” 버튼을 눌러주시면 됩니다.그러면 알아서 변환된 css파일이 생성이 될 것이고, 그 변환된 css파일을 가져다 사용하면 됩니다.Sass에서 변수사용하기$big-size : 20px;$middle-size : 15px;$small-size : 10px;.content {    font-size: $middle-size + 3px;}이렇게 size를 $기호와 함께 변수로 저장해두고 그 값을 가져다 쓸 수 있습니다.또한 사칙연산도 가능합니다.물론 sass를 쓰지 않아도 var()를 사용해서 변수를 만들 수 있고, 사칙연산도 calc()를 사용하면 연산이 가능하지만, 개인적으로는 sass를 쓰는 게 더 편한 것 같습니다.Nesting.content p {  font-size: 14px;}.content .btn {  border-radius: 2px;  background-color: black;  color: white;}.content 안에 p태그와 “btn” 클래스를 가진 버튼이 있다고 가정해보겠습니다. p와 버튼태그에 접근하려면 위의 코드처럼 접근해야합니다. 위의 코드는 간단한 코드이기 때문에 상관없을 수 있지만, 코드가 길어지면 복잡해보일 수 있습니다..content {    p {         font-size: 14px;    }    .btn {        border-radius: 2px;        background-color: black;        color: white;    }}그래서 sass를 사용해서 네스팅을 할 수 있습니다. 이전 코드보다 눈으로 보기에도 훨씬 좋아졌고 관리하기도 쉬워집니다.@extend로 확장하기%button {    width: 50px;    height: 30px;    border-radius: 5px;    font-size: 14px;}.yellow-button {    @extend %button;    background-color: yellow;}.black-button {    @extend %button;    background-color: black;    color: white;}노란색버튼과 검은색버튼을 만들고 싶다고 가정해보면, 중복되는 코드를 “%”를 사용해서 위처럼 임시클래스로 정의해두고 각 버튼에 “@extend”를 사용하여 불러올 수 있습니다. 이렇게 하면 귀찮은 반복을 줄일 수 있는 장점이 있습니다.참고로 %를 사용해서 정의한 임시클래스만 정의해놓으면 그 임시클래스는 컴파일되지 않습니다.@Mixin &amp; @include위의 @extend와 유사하게 사용할 수 있는게 있습니다.@mixin buttonDesign($bgColor, $color) {    width: 50px;    height: 30px;    border-radius: 5px;    font-size: 14px;    background-color: $bgColor;    color: $color;} .yellow-button {    @include buttonDesign(yellow, black);     // 함수처럼 사용이 가능함    // 인자로 배경색은 노란색, 글자색은 검은색을 줌.}함수를 정의하고 호출하듯이 사용할 수 있는 것이 @Mixin 입니다.“@extend”에서 만든 것처럼 노란색 버튼을 위처럼 만들 수 있습니다.“@mixin”을 붙인후 함수처럼 위와 같이 정의해준 후, 그 함수를 불러오듯이 “@include”로 가져오면 됩니다.“@extend”와의 차이는 위처럼 매개변수를 넣을 수 있다는 것입니다.@use외부 css코드를 가져오고 싶을 때 @use를 사용할 수 있습니다.@use '_init.scss\";일반적으로 import하는 것과 같다고 볼 수 있습니다. “@use”와 함께 경로를 써주면 됩니다. 확장자는 생략가능합니다.외부에서 불러온 css파일에서 정의된 변수를 사용하고 싶다면 “파일이름.$변수이름”으로 접근할 수 있습니다.추가로, 종속되는 파일과 같이 단독으로는 컴파일할 필요가 없는 파일들은 파일명 앞에 “_“를 붙여서 컴파일을 하지 않도록 할 수 있습니다.End.",
        "url": "/css-sass"
    }
    ,
    
    "etc-libraryandframework": {
        "title": "라이브러리와 프레임워크",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해오늘은 라이브러리와 프레임워크에 대해서 간단히 정리해보겠습니다.개발을 하다보면 이러한 라이브러리를 가져와서 사용한다, 혹은 OO 프레임워크를 사용한다, 뭐 이런 말들을 자주 들어봤을 것입니다.뭔가 비슷한거같은데 차이점이 뭘까요?라이브러리라이브러리는 단순하게 활용가능한 도구들의 집합이라고 할 수 있습니다. 개발자가 필요할 때 라이브러리를 호출해서 사용합니다. 개발자가 원할 때 함수나 기능의 모음인 라이브러리를 가져다 쓰는 것입니다.프레임워크프레임워크는 뼈대, 기반구조이며 “소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합”입니다. 뭔가 와닿지는 않을 것입니다. 어떤 완성된 어플리케이션이 아니라 개발자가 이 프레임워크를 가지고 프레임워크만의 규칙에 맞게 코드를 프레임워크안에 짜넣어서 개발한다고 보면 되겠습니다.정리쉽게 정리하자면, 필요할 때 개발자가 호출해서 가져다 쓴다면? 👉🏼 라이브러리개발자가 프레임워크에 맞춰서 코드를 작성하고 사용한다면? 👉🏼 프레임워크End.",
        "url": "/etc-libraryandframework"
    }
    ,
    
    "etc-csrssrssg": {
        "title": "CSR, SSR, SSG의 차이",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해오늘은 CSR, SSR, SSG 방식의 차이를 정리해보겠습니다.CSRCSR(Client-Side-Rendering)은 클라이언트 사이드 렌더링의 약자입니다. 말그대로 클라이언트 쪽에서 렌더링을 하는 것을 말하는 것입니다.빈 HTML을 서버로부터 클라이언트가 받게되고, 추가적으로 어플리케이션에서 필요한 자바스크립트파일을 다운받게 됩니다. 이 파일은 어플리케이션에서필요한 로직들과 어플리케이션을 구동하는 프레임워크와 라이브러리의 소스코드들이 포함되어있습니다. 이것들은 파일사이즈가 커서 다운로드 받는데 시간이오래걸릴 수 있습니다. 추가로 필요한 데이터가 있으면 서버에 요청해서 데이터를 받아오며, 이것들을 기반으로 동적으로 HTML을 생성하게 됩니다. CSR은 필요한 부분만 요청하고 응답하기 때문에 서버의 부하가 적고, 초기 로딩이후 속도가 빠릅니다.  그리고TTV와 TTI의 간극이 없어 페이지가 무응답하지 않고 잘 동작합니다. 하지만, 단점도 존재합니다. 이런 CSR(클라이언트 사이드 렌더링)의 문제점은 뭐가 있을까요?일단 사용자가 웹사이트의 처음화면을 보기까지 오래걸릴 수 있다는 것이고, 좋지 않은 SEO가 있겠습니다.검색엔진들이 서버에 등록된 웹사이트들을 하나하나 분석하여, 검색시에 웹사이트를 빠르게 검색할 수 있도록 도와줍니다. CSR방식의 HTML은 대부분 비어져있기 때문에,검색엔진들이 사이트를 분석하기 어려워합니다. 구글에서는 개선이 되었다고는 하지만 여전히 SEO가 좋지 못합니다.SSRSSR(Server Side Rendering)은 서버 사이드 렌더링의 약자입니다. 서버측에서 렌더링하는 것이겠지요.클라이언트의 요청을 받은 즉시, 서버는 화면에 표시하는데 필요한 데이터를 모두 받아와서 HTML을 모두 구성한 다음 브라우저로 전송하는 것입니다.브라우저는 받은 페이지를 바로 화면에 보여주게 됩니다.SSR의 장점은, CSR을 사용했을 때 보다 첫 페이지로딩이 빨라지게 되고, 모든 컨텐츠가 HTML에 담겨져 있기 떄문에 좀 더 효율적인 SEO를 할 수 있습니다.하지만 장점만 있는 것이 아닙니다. 요청시마다 새로고침되기 때문에 깜빡임 이슈가 존재합니다. 또한 TTV와 TTI의 간격이 있다는 것입니다. 페이지는 잘 보일지 몰라도 자바스크립트가아직 적용되지 않은 시간동안에는 페이지가 반응을 하지 못하는 것입니다.SSGSSG라는 것도 존재합니다. SSG(Static Site Generation)은 자주 업데이트되지 않는 사이트에 좋은데, SSR처럼 서버에서 완성된 HTML을 받아오는 것은 맞지만, HTML 파일의 생성이 빌드타임에서 생성됩니다.그러니까 SSR은 요청이 들어오는 즉시 HTML를 만들어서 응답하고, SSG는 빌드시점에 HTML을 미리 만들어두었다가 요청이 들어오면 만들어둔 완성된 HTML을 보내주는 것에 차이가 있습니다.End.",
        "url": "/etc-csrssrssg"
    }
    ,
    
    "css-emandrem": {
        "title": "em과 rem의 차이",
            "author": "ykkim97",
            "category": "",
            "content": "CSS는 다음과 같이 구성되어 있습니다.     CSS의 의미와 적용방법    block과 inline의 차이점    em과 rem의 차이    Sass - CSS 전처리기    CSS margin과 padding의 차이오늘은 css에서 사용되는 em, rem의 차이에 대해서 알아보겠습니다.기본적으로 폰트 크기나, 마진, 패딩과 같은 크기값을 지정할 때 픽셀(px)값으로 지정할 수 있지만,em과 rem이라는 것을 사용하는 경우가 종종 있습니다. 이 차이를 정리해보겠습니다.remrem은 기준이 되는 값의 배수로 변환한 값입니다. 2rem이라면 기준이 되는 값의 2배라는 것이죠.그러면 기준이 되는 값이 뭘까요? 바로 최상위요소(보통은 html)에서 지정된 값이 기준이 됩니다.html {    font-size : 14px;}p {    font-size : 1.5rem;}위의 예시를 보면 html의 font-size가 14px로 지정되어 있고 p태그의 font-size는 1.5rem으로 지정되어있습니다. p의 font-size는 1.5rem이므로 최상위 요소에 지정된 14px의 1.5배 값이 되어 21px이 되는 것입니다.emem도 기준이 되는 값의 배수로 변환한 값인데, 기준이 되는 값이 다릅니다. 바로 이것은 현재 지정요소의 값이 기준이 됩니다.html {    font-size : 14px;}div {    font-size : 16px;}div {    font-size : 1.5rem;}위의 예시를 보면은 div의 font-size값이 16px로 지정되어있고, 바로 밑에 1.5rem 값이 지정되어있습니다. 그러면 16 * 1.5인 24px이 적용이 되는 것이죠.만약에 지정된 기준값이 없다면 어떻게 될까요?해당요소는 부모요소의 지정된 값을 상속받습니다.html { font-size: 10px; }body { font-size: 2em; }div.content { font-size: 2em; }content의 font-size는 2em 이니까, 10px * 2 * 2 = 40px이 되는 것입니다.End.",
        "url": "/css-emAndRem"
    }
    ,
    
    "git-gitaddcommit": {
        "title": "git add , commit, 그리고 staging",
            "author": "ykkim97",
            "category": "",
            "content": "Git은 다음과 같이 구성되어 있습니다.     Github Label별 의미    git add , commit, 그리고 staging    Git Flow 전략에 대해(브랜치 관리 전략)git은 변경사항을 추적하고 여러 명의 사용자들 간에 파일의 작업을 조율하기 위한 “버전 관리”소프트웨어 입니다.오늘은 git 명령중에 git add, commit 명령에 대해서 정리해보겠습니다.git add , commit, 그리고 staging작업폴더에 “test.txt”라는 파일을 생성해서 작성했다고 가정해보겠습니다.이때 “test.txt”파일을 기록하고 싶습니다. 일단, “git add test.txt”라는 명령을 터미널에 입력해주면 됩니다.git add test.txt말 그대로 추가하는 겁니다. 그런데, 어디에 추가하는 걸까요? 바로 리포지토리에 추가가 되는 걸까요?“git add 파일명”이라는 명령은 일단은 Staging Area라는 곳에 파일을 넣어둡니다. Staging Area는 커밋하기전에 커밋할 파일을 골라놓는 곳이고 이런 행위를 스테이징한다고 합니다.이제 여기서 커밋명령을 해주어야합니다.커밋을 해주면 repository에 기록됩니다. 파일 버전을 모아둔다고 말을 합니다.아 물론, 작업폴더안의 전체 파일을 기록하고싶다면 “git add .”을 입력하면됩니다.git add .커밋을 하는 방법은 ‘ git commit -m “쓰고싶은 메세지” ‘를 터미널에 입력해주는 것입니다. 메세지는 현재 커밋하는 내용이 어떤 내용인지 알 수 있게 적어주면됩니다.git commit -m \"테스트용 파일 추가\"정리해보면 커밋하기전에 커밋할 파일을 골라놓는 곳인 “Staging Area”에 “git add”를 통해 파일을 넣어주고, 커밋된 파일버전을 모아놓는 곳인 “repository”에 “git commit”을 통해 커밋합니다.End.",
        "url": "/git-gitaddcommit"
    }
    ,
    
    "javascript-aboutajax": {
        "title": "AJAX가 무엇일까?",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?오늘은 AJAX에 대해서 간단히 정리해보겠습니다.AJAX?AJAX는 “Asynchronous Javascript And XML” 의 약자로 서버와 비동기적으로 데이터를 주고 받는 자바스크립트 기술입니다. AJAX는 웹페이지 전체를 새로고침하지 않아도 페이지의 일부만 갱신할 수 있습니다.이전에는 웹페이지의 작은 일부가 변해도 새로운 페이지 전체를 다시 로드해야했습니다. 그래서 화면이 깜빡이는 현상이 있었고, 이것은 시간적으로나 자원적으로나 낭비입니다.하지만 AJAX를 이용하면 페이지 전체가 아니라, 일부분만 갱신할 수 있습니다. 따라서 깜빡임 현상도 일어나지않고 새로고침없이 화면이 부드럽게 전환됩니다.AJAX의 장단점  장점  웹페이지의 전체를 재로딩하지 않아도, 일부분만 갱신가능하다.  불필요한 데이터 요청을 최소화할 수 있고 많은 일이 클라이언트 웹 브라우저에서 처리가능  단점  보안에 주의해야한다.  연속해서 데이터를 요청을 남발하면 서버 부하가 생길 수 있다.이외에도 장단점이 있겠지만 크게는 이렇습니다.사용법사용법은 여러 방법이 있는데 간단히 정리해보자면 다음과 같습니다. (전통적인 방법은 제외)  fetch함수 사용  jQuery의 ajax()함수 사용  리액트나 뷰와 같은 환경에서는 axios 라이브러리 설치하여 사용End.",
        "url": "/javascript-aboutajax"
    }
    ,
    
    "javascript-scripttag": {
        "title": "script, script async, script defer의 차이",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?오늘은 script 태그에 대해서 알아보겠습니다.script태그는 자바스크립트를 정의할 때 사용합니다. 문서파일에 자바스크립트를 추가하는 방법이 3가지가 있는데, 각각 특징이 다릅니다.이것에 대해서 정리해 보도록 하겠습니다.script, script async, script defer 의 차이      script그냥 일반적인 방법입니다. HTML을 파싱하는 중에 이 script태그를 만나면 HTML파싱을 중지하고 스크립트를 다운받아 파싱하고 실행합니다.이것이 완료되면 다시 HTML을 파싱합니다.        script asyncasync 속성이 붙은 경우입니다. 이것은 HTML파싱을 하면서 script태그를 만나면 문서를 파싱하면서 스크립트를 다운받습니다. 다운이 완료되는 즉시 HTML 파싱을 멈추고 스크립트를 실행합니다. 실행이 끝나면 남은 HTML 문서를 분석합니다.        script deferdefer 속성이 붙은 경우는 async 처럼 script태그를 만났을 때 스크립트를 다운받는데, HTML파싱이 모두 완료되면 받아놓은 자바스크립트를 실행하게 됩니다.HTML을 파싱하는 동안 필요한 자바스크립트파일을 받아놓고 HTML을 모두 파싱해서 사용자에게 페이지를 먼저 보여준 후 바로 이어서 자바스크립트를 실행합니다.  정리  script 태그 : HTML 파싱중에 script 태그 만남 -&gt; HTML파싱을 중지하고 스크립트 다운,파싱,실행 -&gt; 끝나면 다시 HTML파싱  script async 태그 : HTML 파싱중에 script 태그 만남 -&gt; 아직 HTML 파싱을 중지시키지 않고 스크립트 다운 -&gt; 다운완료되면 그때서야 HTML파싱 중지 후 스크립트 실행 -&gt; 끝나면 다시 HTML파싱  script defer 태그 : HTML 파싱중에 script 태그 만남  -&gt; HTML파싱을 중지시키지 않고 스크립트를 다운받음 -&gt; 다운완료되어도 HTML파싱을 모두 완료한 후에야 스크립트를 실행함.End.",
        "url": "/javascript-scripttag"
    }
    ,
    
    "etc-processandthread": {
        "title": "프로세스와 쓰레드의 차이점",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해오늘은 프로세스와 쓰레드에 대해서 정리해보겠습니다.프로세스? 쓰레드?프로세스는 한마디로 실행중인 프로그램이라고 할 수 있습니다. 여기서또 프로그램과 프로세스를 혼동할 수 있는데 프로그램은 실행가능한 명령어들의 집합입니다.그러면 쓰레드는 뭘까요?그 프로세스 내에서 동작되는 여러 실행의 흐름입니다.둘의 차이점프로세스는 최소 하나의 쓰레드를 보유하고 있고 각각 별도의 주소공간을 할당받습니다. 독립적이죠.그런데 쓰레드는 Stack을 제외하고 Code, Data, Heap의 나머지 영역을 서로 공유합니다.프로세스 메모리 영역잠깐 프로세스 메모리 영역에 대해서 알아보겠습니다.커널 메모리 안에서 관리되는 PCB(Process Control Block) 정보외에 유저가 사용하는 메모리안의 프로세스 정보는 4가지가 있는데, Code, Data, Heap, Stack이 있습니다.  Code: 프로그램의 실제 코드 저장  Data: 프로세스가 실행될 때 정의된 전역 변수. Static 변수들을 저장  Heap: 프로세스 런타임 중 동적할당 변수들을 저장  Stack: 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간이고 함수 호출 시에 기록하고 끝나면 사라진다.멀티프로세스 vs 멀티쓰레드멀티프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하여 각각의 프로세스가 하나의 작업을 처리하는 것이고 멀티쓰레드는, 하나의 프로그램을 여러개의 쓰레드로 구성하고 각 쓰레드가 하나의 작업을 처리하는 것입니다. 자세한 차이점은 다음과 같습니다.  멀티프로세스는 각 프로세스가 독립적이고 쓰레드는 서로 긴밀하게 연결되어있습니다.  멀티프로세스는 IPC를 사용한 통신을 해야하는데, 쓰레드는 공유된 자원으로 통신비용이 절감됩니다.  멀티프로세스는 개별 메모리를 차지하는데 쓰레드는 자원을 공유하기 때문에 좀더 효율적입니다.  멀티프로세스는 Context Switching 비용이 멀티쓰레드보다 비효율적입니다.  멀티프로세스는 동기화작업이 필요하지 않고, 멀티쓰레드는 공유자원을 관리해야 합니다.End.",
        "url": "/etc-processandthread"
    }
    ,
    
    "etc-whatisbundle": {
        "title": "번들링이 뭔데?",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해오늘은 번들링이 무엇인지, 번들링을 하는 이유가 뭔지 간단히 알아보겠습니다.번들링에 대해우리가 웹사이트를 만들다보면 자바스크립트, CSS, 이미지와 같은 정말 많은 파일들이 생겨나게 됩니다.그래서 웹사이트를 로딩해보면 그 수많은 파일들이 다운로드되는 것을 확인할 수 있는데, 이는 서버와의 접속이 많아지게 되고 어플리케이션이 느려지게 됩니다. 또한 여러 많은 JS패키지를 사용하다보면 각각의 패키지들이 서로 같은 변수명, 함수명을 사용하여 예상치 못한 충돌이 발생할 수도 있습니다.이러한 문제를 해결할 수 있는 것이 “번들러”입니다. 어플리케이션을 구성하는 여러 파일들을 하나의 파일로 병합해주는 과정을 번들링이라고 하고 그걸을 하는 것이 번들러입니다.대표적으로 Webpack이 있습니다.번들링의 장점      번들링하지 않은 경우는 각 파일마다 서버에 요청해서 자원을 얻어와야했는데, 번들링하면 하나의 파일로 만들어지기 때문에 페이지 로딩이 빨라지고 네트워크 접속의 부담을 줄일 수 있습니다.        Webpack에서는 로더(Loader)를 통해 바벨이라는 ES6+ 문법을 ES5로 변환할 수 있도록하는 트랜스파일러를 사용할 수 있습니다. 오래된 브라우저에서도 동작할 수 있도록 해주는 장점이 있습니다.        번들러는 자바스크립트 파일을 기능 단위로 모듈화 하고 이것을 묶어 관리할 수 있게 합니다. 번들러를 사용함으로써 소스 코드를 모듈별로 작성할 수 있고 모듈간 혹은 외부 라이브러리의 의존성을 쉽게 관리 할 수 있습니다.이외에도 많은 장점이 있을 수 있지만 3가지 정도만 정리해봤습니다.  End.",
        "url": "/etc-whatisbundle"
    }
    ,
    
    "etc-bubbling": {
        "title": "이벤트 버블링과 캡처링",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해오늘은 이벤트 버블링과 캡처링에 대해서 알아보겠습니다.이게 도대체 무엇일까요?버블링과 캡처링&lt;div onclick=\"alert('DIV에 할당된 클릭이벤트')\"&gt;    &lt;p&gt;눌러봐&lt;/p&gt;&lt;/div&gt;위의 핸들러는 &lt;div&gt;에 할당이 되어있습니다. 하지만 그 안에있는 &lt;p&gt;태그를 눌러도 핸들러가 동작합니다.뭔가 이상하지 않나요?? 분명 &lt;p&gt;태그를 눌렀는데 왜 &lt;div&gt;에 할당된 핸들러가 동작하는걸까요…?&lt;form onclick=\"alert('form')\"&gt;FORM  &lt;div onclick=\"alert('div')\"&gt;DIV    &lt;p onclick=\"alert('p')\"&gt;P&lt;/p&gt;  &lt;/div&gt;&lt;/form&gt;또 다른 예시를 보면서 알아보겠습니다. 위 HTML코드를 보면 &lt;form&gt;태그 안에 &lt;div&gt;태그가 있고, 또 그 안에는 &lt;p&gt;태그가 있습니다.그리고 각 태그에는 클릭 이벤트 핸들러가 할당되어 있는 상태입니다.가장 안쪽에 존재하는 &lt;p&gt;태그를 클릭하면 다음 순서대로 동작합니다.  먼저 &lt;p&gt;의 핸들러가 동작합니다.  그 다음 상위태그인 &lt;div&gt;의 핸들러가 동작합니다.  그 다음 상위태그인 &lt;form&gt; 핸들러가 동작합니다.  document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작합니다.다음과 같은 과정으로 alert창이 p -&gt; div -&gt; form 순으로 3개가 열립니다. 이러한 흐름을 ‘이벤트 버블링’이라고 하는 것입니다.가장 안쪽의 요소부터 가장 최상단까지 거슬로 올라가면서 발생하는 모양이 물속의 거품(bubble)과 닮았기 때문이라고 합니다.‘버블링’과 반대로, 상위요소에서 하위요소로 이벤트가 전파되는 경우를 ‘이벤트 캡처링’이라고 합니다. 물론 자주쓰이는 경우는 아닙니다.Event FlowDOM 이벤트는 3가지 단계가 존재합니다.  Capture Phase (캡처링 단계)  Target Phase (타켓 단계)  Bubble Phase (버블링 단계)기본적으로 이벤트 흐름은 Capture Phase 👉🏼 Target Phase 👉🏼 Bubble Phase 순으로 흐르게 됩니다.그런데 여기서 의문이 생깁니다.DIV와 BODY와 HTML 모두 클릭 이벤트가 있다고 가정해보겠습니다.div를 클릭하게 되면 위의 이벤트 흐름에 따라서 다음과 같이 이벤트가 발생할 것 입니다.  캡처링 단계에 의해 HTML 클릭이벤트 =&gt; body 클릭이벤트 순으로 발생  타켓 단계에 의해 이벤트의 target인 div의 클릭이벤트 발생  버블링 단계에 의해 ody 클릭이벤트 =&gt; HTML 클릭이벤트 순으로 다시 발생그러면… 저 DIV하나 눌렀다고 클릭이벤트가 몇번 발생하게 되는거지…? 그렇습니다. 정말 복잡해집니다.그래서 저 DIV, 즉 이벤트를 발생시킨 주체를 제외한 나머지 요소들은 이벤트가 캡처단계에서 발생될 것인지, 버블단계에서 발생될 것인지 선택할 수 있습니다.기본적으로 브라우저는 ‘버블’이 기본값입니다.const html = document.documentElement;const body = document.body;const div = document.querySelector('div');div.addEventListener('click', function () {  console.log('DIV')})body.addEventListener('click', function () {  console.log('BODY')}, true)html.addEventListener('click', function () {  console.log('HTML')})위 처럼 이벤트리스너의 첫번째 인자는 이벤트 타입, 두번째 인자는 리스너가 들어가는데 세번째인자로 true, false값을 넣어줄 수 있습니다.기본값은 false이고 아무값도 넣지 않는다면 false인 상태로 ‘버블’인 것이고, true값을 넣어준다면 ‘캡처’가 적용되는 것입니다.위에서는 body에 true를 넣어서 캡처링을 적용한 것입니다.이렇게 이벤트 캡처링과 버블링에 대해서 정리해보았습니다.End.",
        "url": "/etc-bubbling"
    }
    ,
    
    "etc-dom": {
        "title": "DOM이란?",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해DOM을 어느정도는 대충 알지만 누군가가 DOM이 무엇이냐고 다짜고짜 묻는다면 명확히 대답하기 어려웠습니다.그래서 DOM에 대해서 공부한 내용을 간략히 정리해보려고 합니다.DOM ?DOM은 Document Object Model의 약자입니다. 문서 객체 모델이라고도 합니다.그냥 문서 객체 모델? 로 해석하려고 하면 잘 이해가 되지 않습니다.쉽게 정리하면 DOM은 HTML 코드를 해석해서 요소들을 트리형태로 구조화해 표현하는 형식입니다. 그러니까 브라우저가 HTML 코드를 해석해서 트리 형태로 구조화해서 표현하는 문서(데이터)를 생성하게 되는데 이게 DOM인 것입니다. 브라우저는 DOM을 통해서 화면에 웹 컨텐츠를 렌더링합니다.DOM의 목적HTML코드를 해석해서 그대로 브라우저에 렌더링해주는 것이 브라우저의 역할인데 왜 중간에 DOM을 형성하는 걸까요?자바스크립트를 사용해서 이 문서에 대한 스크립트를 작성할 수 있게 해주는 데 목적이 있기 때문입니다.DOM은 자바스크립트를 사용해서 웹 컨텐츠를 추가, 수정, 삭제, 이벤트 처리 등을 정의할 수 있도록 제공되는프로그래밍 인터페이스입니다. 자바스크립트가 어떤 동작을 구현하면 DOM에 그 결과가 반영되어 웹브라우저 화면이 다시 렌더링됩니다. HTML 코드는 정적인데, 화면이 사용자와 동적인 상호작용을 하는데 DOM이 그 역할을 해주는 것입니다.End.",
        "url": "/etc-dom"
    }
    ,
    
    "etc-browser": {
        "title": "브라우저의 동작 원리",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해브라우저의 동작 원리브라우저는 웹사이트를 표시해주는 소프트웨어이며 웹 개발자들에게는 없어서는 안될 존재입니다.브라우저는 어떤 원리로 동작하게 되는 것일까요? 주소창에 주소를 입력했을 때 어떤 과정을 거쳐서 웹페이지가 화면에 보이게 되는 것일까요?브라우저의 종류브라우저는 크롬, 사파리, 파이어폭스, 오페라, 인터넷 익스플로러, 네이버웨일 등 여러가지가 있습니다. 현재는 크롬이 가장 많이 사용되고 있습니다.브라우저의 주 기능브라우저의 주 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저화면에 표시하는 것입니다. 여기서 자원은 보통 HTML문서이고 PDF나 이미지 등 다른형태도 포함될 수 있습니다. 자원의 주소는 URL에 의하여 정해집니다.브라우저는 HTML, CSS 명세에 따라서 HTML파일을 해석하고 표시합니다. 이 명세는 웹표준화기구(W3C)에 정하는데 과거에는 여러 브라우저가 각각 다른 방법으로확장했고 이는 호환성의 문제를 발생시켰습니다. 하지만 현재는 거의 대부분의 브라우저들이 표준화된 명세를 따르게 되었습니다.브라우저의 UI는 일반적으로 다음과 같이 구성되어있습니다.  주소 표시줄  뒤로가기,앞으로가기  중지, 새로고침  홈버튼  북마크브라우저의 UI는 표준 명세가 없음에도 계속해서 브라우저들끼리 서로를 모방하면서 거의 비슷한 UI를 가지게 되었습니다. 물론 특정한 브라우저가 가지고 있는기능도 있긴합니다.브라우저의 기본 구조  사용자 인터페이스 - 주소 표시줄, 뒤로가기, 앞으로가기, 중지, 새로고침, 홈버튼, 북마크 등  브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어  렌더링 엔진 - 요청한 컨텐츠를 표시함.  통신 - HTTP 요청과 같은 네트워크 호출에 사용됨.  UI 백엔드 - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.  자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행함.  자료저장소 - 자료를 저장하는 계층.렌더링 엔진렌더링엔진은 요청한 컨텐츠를 표시하는 녀석입니다. 파이어폭스의 경우 “개코”엔진, 사파리나 크롬은 “웹킷”엔진을 사용합니다.동작 과정에 대해렌더링엔진은 통신으로부터 요청한 문서의 내용을 얻는데 보통 문서내용은 8KB 단위로 전송됩니다.자, 렌더링엔진의 기본 동작 과정은 다음과 같습니다.  HTML문서를 파싱하여 DOM트리를 구축  CSS파일과 같은 스타일 요소를 파싱(CSSOM트리 구축)  이 둘을 합쳐서 렌더트리를 구축 (렌더트리는 문서를 시각적인 구성 요소로 만들어 주는 역할을 함)  렌더 트리 각 노드에 대해서 화면 상에 배치할 곳을 결정  UI 백엔드에서 렌더 트리의 각 노드를 그림.정리하면 브라우저가 서버로 부터 HTML문서를 전달받아서 HTML파서를 통해서 파싱하고 DOM트리를 생성합니다. 또한 CSS파일과 같은 스타일요소도 파싱되어 CSSOM트리를 생성합니다. 그다음에 DOM과 CSSOM이 합쳐져서 렌더트리를 구축하거 렌더트리를 배치합니다. 여기서 렌더트리는 위치와 크기를 가지고 있지 않기 때문에 어느 공간에위치해야할지 각 객체들에게 위치와 크기를 결정해줍니다. 이어서 렌더트리가 만들어져 레이아웃이 구성됬으면 UI 백엔드가 동작하여 렌더 트리의 각 객체를 화면의 픽셀값으로나타냅니다.자바스크립트는?HTML과 CSS는 렌더링엔진에서 처리가되는데 자바스크립트는 어떨까요?자바스크립트는 렌더링엔진에서 처리가 되는 것이 아니라 자바스크립트 엔진이 처리하는 것입니다. HTML파서가 script태그를 만나면 자바스크립트코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트엔진에게 권한을 넘기게 됩니다. 넘겨받은 자바스크립트엔진이 script태그 내의 자바스크립트 코드를 로드하고 파싱하여 실행합니다.실행이 완료되면 다시 HTML파서로 제어 권한을 넘겨서 중지했던 시점으로 넘어가 DOM 생성을 재개하게 되는 것입니다.브라우저는 HTML, CSS, JS를 동기적으로 처리합니다. 그런데 자바스크립트 엔진에 제어 권한이 있는 상태에서 자바스크립트 코드가 아직 완성지 않은 DOM을 조작하게 되면 어떻게 될까요?당연히 에러가 발생할 겁니다. 그래서 자바스크립트 코드를 &lt;body&gt;태그 하단에 위치시키는 것입니다.End.참조한 자료 :https://bbangson.tistory.com/87.https://d2.naver.com/helloworld/59361.",
        "url": "/etc-browser"
    }
    ,
    
    "javascript-aboutthreejs": {
        "title": "Three.js에 대해서",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?요즘 새로 배워보고 싶은 것이 하나 생겼다. 그것은 바로 Three.js이다. 뭔가 웹사이트를 만들 때 조금 더 멋있고 인터렉티브하게 만들고 싶었고, 관련정보를 찾아보다가 이 three.js에 대해서 알게되었다. 그래서 배우면서 알게된 내용을 정리해 나가려고 한다.Three.js ?먼저 WebGL이라는 것에 대해서 알아볼 필요가 있다. WebGL은 웹 상에서 그래픽을 나타낼 수 있는 라이브러리다.그런데 이 WebGL API 자체가 완전 로우 레벨이라서 처음부터 하나하나 개발해 나가야 하고 코드양도 많으며 복잡하다고 한다.Three.js는 이 WebGL을 조금 더 쉽고 간편하게 사용할 수 있도록 도와주는 라이브러리인 것이다.공식사이트는 다음과 같다.Threejs.org.물론 Three.js 말고도 다른 라이브러리들이 있지만 현재는 Three.js가 가장 인기가 많다고 한다.저 공식사이트에는 이것을 활용하여 만들어진 사이트들을 확인할 수 있다.https://eyes.nasa.gov/apps/mars2020/.위 이미지에서 볼 수 있듯이 웹 상에서 화성을 표현하고 우주를 표현하는 등 멋진 표현을 웹사이트에 적용할 수 있는 것이다.three.js는 공식사이트에서 다운받거나 npm을 통해서 설치하는데 보통은 npm으로 다운받는 편이다.다음 글에서 three.js에 대해서 좀더 자세히 정리해보도록 하겠다.End.",
        "url": "/javascript-AboutThreejs"
    }
    ,
    
    "html-doctype": {
        "title": "DOCTYPE의 의미?",
            "author": "ykkim97",
            "category": "",
            "content": "HTML은 다음과 같이 구성되어 있습니다.     웹의 기본중의 기본! HTML에 대해서 알아보자    HTML 기본 태그들    DOCTYPE의 의미?    시맨틱 태그?DOCTYPE의 의미가 무엇일까? DOCTYPE은 Document Type의 약어로 문서의 유형을 정의하기 위해 사용하는 선언문(DTD, Documnet Type Definition)입니다.&lt;!DOCTYPE html&gt;&lt;!--     ...... --&gt;위처럼 html 문서 맨 처음에 선언하는데 이는 웹문서의 시작을 알려주고 웹 브라우저에서 처리할 문서가 html이며 어떤 버전으로 사용하였으니해당 방식으로 해석하라는 의미를 갖습니다. HTML5 이전에는 DOCTYPE을 선언하는 코드가 까다로웠지만 HTML5 부터는 간단하게 할 수 있게 되었습니다.End.",
        "url": "/html-doctype"
    }
    ,
    
    "etc-firebasedbrules": {
        "title": "Firebase DB에서 값을 불러올 수 없는 문제 해결",
            "author": "ykkim97",
            "category": "",
            "content": "기타 포스팅입니다.     Firebase DB에서 값을 불러올 수 없는 문제 해결    브라우저 동작 원리    DOM이란?    이벤트 버블링과 캡처링    번들링이 뭔데?    프로세스와 쓰레드의 차이점    CSR, SSR, SSG의 차이    라이브러리와 프레임워크    쿠키와 웹스토리지에 대해Firebase DB에서 값을 불러올 수 없는 문제 해결진행 중에 있는 프로젝트의 버그를 수정하기 위해 확인을 했는데 갑자기 문제가 발생했다…Firebase의 Realtime Database, Storage에 있는 데이터를 불러오지 못하는 문제였다. 처음에는 코드를 잘못만진게 아닌가 싶었는데,그런 이유는 아니었고 Firebase와 연동 자체가 안되는 문제였다. 갑작스러웠지만 인터넷 검색을 통해 문제를 해결하려고 노력했다.firebase 알림에 위와 같은 메세지가 와있는 것을 발견했는데, 보안규칙을 업데이트 해야한다는 것을 알았다.처음 데이터베이스를 사용할 때 잠금모드와 테스트모드중 테스트모드를 선택했는데 생각해보니 테스트모드는 30일이 지나면 데이터베이스에서 읽을 수 없도록 되어있었다.계속 유지하려면 보안 규칙설정을 해줘야한다.위처럼 보안규칙을 바꿔주었더니 다시 정상적으로 동작했다.물론 보안 규칙이 공개로 정의되어 있어 누구나 데이터베이스의 데이터를 도용, 수정, 삭제할 수 있지만 아직은 개발단계이기 때문에 일단 이렇게 수정해놓고 사용하기로 했다.Firebase 공식 문서 참조https://firebase.google.com/docs/rules/insecure-rules#database End.",
        "url": "/etc-firebasedbrules"
    }
    ,
    
    "javascript-hoisting": {
        "title": "호이스팅이란 , var, let, const 차이",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?호이스팅에 대해서“hoisting”의 사전적 의미는 “끌어올리기”라는 뜻이다. 일단 hoisting은 함수가 실행되기전에 안에 있는 변수들을 그 유효범위의 최상단으로 끌어올리는 것을 의미합니다.var 키워드의 문제점?ES6 이전까지는 변수를 선언할 때 var 키워드만 사용할 수 있었습니다. 하지만 var 키워드는 문제점이 있었습니다.1) 변수의 중복 선언 허용 문제var x = 1;var x = 2;console.log(x);x라는 동일한 이름의 변수가 선언된 것을 확인할 수 있는데, 먼저 선언된 x의 값이 변경되버리는 문제가 발생합니다.2) 함수 레벨 스코프var 키워드로 선언한 변수는 함수의 코드블록만 지역 스코프로 인정합니다. 함수를 제외하고 if나 for문안에 var 키워드를 사용하여 변수를 선언했다면? 지역변수로 취급을 하지않고 전역변수로 취급됩니다. 따라서 함수레벨스코프는 전역변수를 남발할 가능성을 높입니다.3) 변수 호이스팅var 키워드로 변수를 선언하면 변수 호이스팅에 의해 그 선언문이 범위의 최상단으로 끌어 올려진 것처럼 동작합니다. 변수 선언문 이전에 그 변수를 참조할 수 있다는 것인데, 에러를 발생시키지 않지만 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남기는 문제가 있습니다.let과 const의 등장이런 var의 문제를 해결하고자 ES6에서 let과 const를 도입하였습니다. let 키워드부터 살펴보겠습니다.let은 변수 중복 선언을 금지하고, 함수의 코드블록만 지역스코프로 인정하는 var와 달리 모든 코드블록을 지역스코프로 인정하는 블록레벨스코프를 따릅니다.또한 let키워드로 선언한 변수는 “선언”과 “초기화”단계가 분리되어 진행됩니다. 런타임 이전에 자바스크립트 엔진에 의해 선언단계가 먼저 진행되지만 초기화단계는 실제 변수 선언문에 도달했을 때 실행됩니다.let 키워드로 선언한 변수는 스코프의 시작부터 초기화단계가 시작되는 시점(변수 선언문)까지 변수를 참조할 수 없습니다. 이 구간을 일시적 사각지대(Temporal Dead Zone)라고 합니다.이번엔 const 키워드를 알아보겠습니다.const 키워드는 상수를 선언하기 위해서 사용되는데, 꼭 상수만을 위해 사용하는 것은 아닙니다.const는 대부분 let과 동일하지만 const 키워드로 선언된 변수는 꼭 선언과 동시에 초기화를 해주어야하고 변수의 재할당이 불가능합니다. 주의해야할 점이 있는데, const로 선언된 변수에 원시값을 할당한 경우는 값을 변경하지 못하는게 맞지만 const로 선언된 변수에 객체를 할당한경우 값을 변경할 수 있습니다. const는 재할당을 금지하는 것이지 불변을 의미하는 것이 아닙니다.그럼 무엇을 보통 쓸까?변수 선언은 기본적으로 const를 사용하는 것이 좋고 let은 재할당이 필요할 때 사용하는 것이 좋습니다. 추가적으로 var는 권장하지 않는 방법입니다.End.",
        "url": "/javascript-hoisting"
    }
    ,
    
    "javascript-eventloop": {
        "title": "JS Event Loop, 자바스크립트 동작 원리",
            "author": "ykkim97",
            "category": "",
            "content": "JavaScript 관련 글입니다.     JS Event Loop, 자바스크립트 동작 원리    호이스팅이란 , var, let, const 차이    Three.js에 대해    script, script async, script defer의 차이    AJAX가 무엇일까?    함수선언식과 함수표현식    null과 undefined의 차이 간단정리    setTimeout과 setInterval 요약    this의 여러가지 의미    Spread Operator(...)?    JS class Constructor    ES6 Destructuring Syntax    default 파라미터 알아보기    import / export 를 사용한 모듈식 개발방법    Optional Chaining (?.)    프로미스(Promise)에 대해서    ES8 - async / await    Symbol 자료형?JS Event Loop에 대해서Javascript Engine?일단 Javascript Engine과 Rendering Engine은 다릅니다. Rendering Engine(Layout Engine)은 HTML과 CSS로 작성된 마크업 관련 코드를 웹 페이지에 렌더링하는, 그려주는 역할을 하는 것이고 반면 Javascript Engine은 자바스크립트로 작성된 코드를 해석하고 실행시켜주는 인터프리터입니다.구글의 V8과 같은 자바스크립트엔진은 Call Stack, Task Queue, Heap으로 크게 나뉘고 추가적으로 Event Loop라는것이 있는데 Task queue에 들어가는 task들을 관리합니다.Call Stack자바스크립트는 한개의 Call Stack을 사용합니다. 코드 요청이 들어올 때마다 순차적으로 Call Stack에 담아서 처리합니다. 메소드가 실행이되면 Call Stack에 새로운 프레임이 생기고, push되고 메소드의 실행이 종료되면 해당 프레임은 pop됩니다.Heap(Memory Heap)동적으로 생성된 객체는 Heap에 할당이 됩니다. 구조화 되지 않는 더미같은 메모리 영역을 힙(heap)이라고 합니다. 정리하면 변수 선언, 함수 저장, 호출 이런 작업이 발생하는 공간입니다.Task Queue(Event Queue)처리해야하는 Task들을 임시로 저장하는 대기 큐가 존재합니다. 이것을 Task Queue라고 합니다. 이 Task Queue에 존재하는 Task들은 Call Stack이 비어졌을 때 대기 큐에 들어온 순서대로 Call Stack에 올려져서 수행됩니다. 자바스크립트에서는 비동기적으로 호출되는 함수들은 Call Stack으로 바로들어가지 않고 Task Queue에 들어가게 됩니다. 예를들어 Ajax요청코드, 이벤트리스너, setTimeout같은 것들이 있습니다. 결론자바스크립트 코드가 실행되면 Call Stack에 하나씩 들어가서 처리가되는데 Ajax요청코드, 이벤트리스너, setTimeout같은 것들은 Task Queue에 들어가서 대기합니다. Event Loop가 Call Stack이 비어있는지 확인하고 비어있다면 Task Queue에서 하나씩 Call Stack으로 보냅니다. 보내진 작업은 똑같은 과정을 거쳐서 처리가 되는 것입니다. End.",
        "url": "/javascript-eventloop"
    }
    ,
    
    "git-githubissuelabel": {
        "title": "Github Label별 의미",
            "author": "ykkim97",
            "category": "",
            "content": "Git은 다음과 같이 구성되어 있습니다.     Github Label별 의미    git add , commit, 그리고 staging    Git Flow 전략에 대해(브랜치 관리 전략)Github 기본 Label들프로젝트를 하면서 많은 이슈가 발생하게 되고 이런것을 관리하는 것의 필요성을 느끼고 이슈관리에 대해서 공부하던 중 이슈에 라벨이라는 것을 달 수 있게 되어있었다. 여러가지가 있었는데 다음과 같다.깃허브의 이슈, PR(Pull Request)에 Label을 지정할 수 있다. 제공되는 라벨은 다음과 같다.            라벨      의미                  bug      예기치 않은 문제 또는 의도하지 않은 동작(버그)을 나타냅니다.              documentation      문서를 개선하거나 추가 할 필요가 있음을 나타냅니다.              duplicate      해당이슈 또는 PR이 기존에 있음을 나타냅니다.              enhancement      새로운 기능 요청을 나타냅니다.              good first issue      처음 기여해볼 사람에게 좋은 문제를 나타냅니다              help wanted      관리자가 문제 또는 PR 요청에 대한 도움을 원함을 나타냅니다.              invalid      이슈 또는 PR 요청이 더 이상 관련이 없음을 나타냅니다.              question      이슈 또는 풀 요청에 추가 정보가 필요함을 나타냅니다.              wontfix      문제 나 PR 요청에서 작업이 계속되지 않음을 나타냅니다.      End.",
        "url": "/git-githubissuelabel"
    }
    ,
    
    "react-usestate": {
        "title": "useState에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해useState?useState로 데이터를 저장해보자.우리는 보통 데이터를 저장할 때 다음과 같이 변수에 데이터를 저장합니다.let data = 'test data';이것은 기본적인 방법입니다. 리액트에서는 이것 말고 state라는 것을 만들어서 데이터를 저장할 수 있습니다.import { useState } from \"react\";function App() {    const [data, setData] = useState('test data');    return (        &lt;div&gt;            &lt;h3&gt;{data}&lt;/h3&gt;        &lt;/div&gt;    )}위 코드는 useState라는 훅을 사용하는 한 예제입니다.먼저 useState를 import를 합니다. 그리고 []안에 data와 setData, 이 두가지의 값이 올 수 있는데 첫번째 값은 data는 초기값에 해당하고,두번째 값인 setData는 data라는 값을 변경할 때 사용하는 함수입니다. data의 초기값으로는 현재 ‘test data’라는 문자열이 인자로 들어와 있는상태입니다.이렇게 정의하고 data라는 값을 사용하면 끝입니다. 사실 별거 없습니다.실제로 확인해보면 ‘test data’라는 문자열이 화면에 보여질 것입니다.setState위에서 사용했던 예제 코드에 버튼을 하나 추가해보겠습니다.import { useState } from \"react\";function App() {    const [data, setData] = useState('test data');    return (        &lt;div&gt;            &lt;h3&gt;{data}&lt;/h3&gt;            &lt;button onClick={() =&gt; setData('change data')}&gt;change&lt;/button&gt;        &lt;/div&gt;    )}이 버튼은 onClick 이벤트를 발생합니다. 클릭 시에는 setData()가 실행될 것입니다.setData함수는 위에서 설명했듯이 data라는 state의 값을 변경하는데 사용되는 함수 입니다. 함수의 파라미터로 문자가 변경되었다는 것을 나타내보기위해‘change data’라는 문자열을 집어넣었습니다. 이렇게 하면 버튼을 클릭했을 때 ‘change data’로 data의 값이 변경될 것입니다.실제로 확인해보면 값이 변경될 것입니다.state를 사용하는 이유?state를 사용하는 이유가 무엇일까요?사실 일반적인 변수로 저장해서 사용하는 것이 더 간단해 보이기도 합니다.그러나 state는 변경이 생길 경우 그 state를 사용하는 html을 자동으로 재렌더링 해줍니다.일반적인 변수를 사용하고 그 변수를 데이터바인딩했다고 가정할 경우 변수를 변경 후 html에도 변경사항을 반영하려면 직접 반영할 수 있도록 코드를 추가해줘야합니다. 하지만 state를 사용하면 추가적인 코드없이 자동으로 html을 재렌더링 해주기 때문에 UI를 개발할 때 편리하고 부드럽게 동작할 수 있습니다.물론 모든 데이터를 state로 저장할 필요는 없습니다. 상황에 따라서 사용하면 되는데 데이터가 자주 변경될 것 같은 데이터는 state를 사용하면되고, 별로 안바뀔거같은데이터는 변수로 저장해도 무방합니다. End.",
        "url": "/react-usestate"
    }
    ,
    
    "react-lazysuspense": {
        "title": "React - lazy, Suspense에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React - lazy, Suspense이번 포스팅에서는 lazy와 Suspense에 대해서 알아보겠습니다.React로 개발한 사이트들은 기본적으로는 SPA(Single Page Application)입니다.사이트를 빌드하면 하나의 큰 JS파일, HTML, CSS파일 등이 생성이 됩니다.하나의 JS파일안에 모든 컴포넌트, 페이지, 여러 기능들이 모두 모여있게 되는데 이는 용량이 제법 크기 마련입니다. 그래서 사용자가 사이트 메인페이지에 접속하게 되면 그 큰 JS파일을 받아야하기 때문에 초기 로딩속도가 느릴 수 있습니다. 따라서 아무것도 없는 흰 화면을 오래볼 가능성이 있습니다.따라서 이 하나의 JS파일을 분할을 하게되면 이런 문제점을 조금은 해결할 수 있습니다.이것은 당장 필요없는 페이지를 천천히 로드할 수 있도록 하면되는데 lazy라는 함수를 사용하면 됩니다.아래 예시를 보겠습니다.Detail이라는 페이지가 있습니다. 기본적으로는 다음과 같이 import를 하는 것이 맞습니다.import Detail from \"./routes/Detail\";하지만 이 Detail페이지가 당장 필요하지 않은 페이지라면 다음과 같이 lazy()라는 함수를 이용할 수 있습니다.import React, { lazy, Suspense } from 'react';const Detail = lazy(() =&gt; import('./routes/Detail.js'));이렇게 하게 되면 Detail페이지가 필요해질 때 import를 하게 됩니다.이런식으로 import를 하게 되면 초기로딩속도를 개선할 수 있습니다.물론 사이트를 발행할 때도 하나의 jS가 아니라 별도의 JS파일로 분리가 됩니다.Suspense물론 lazy로 import하는 방식도 단점이 있을 수 있습니다.Detail페이지가 필요해지는 시점에서는 약간의 지연시간이 발생할 수 있습니다.초기에 import되지 않고 필요해지는 시점에서 import를 하기 때문입니다.지연되는 시간동안 사용자는 역시 흰 화면을 보게될 것입니다.이런 경우 Suspense를 활용하여 로딩페이지를 띄워주면 좋을 것입니다.&lt;Route exact path='/detail' element={  &lt;Suspense fallback={&lt;div&gt;로딩중입니다. 조금만 기다려주세요!&lt;/div&gt;}&gt;    &lt;Detail /&gt;  &lt;/Suspense&gt;}&gt;&lt;/Route&gt;위와 같이 Detail페이지를 Suspense안에 넣어주면 됩니다. 추가로 fallback이라는 것의 값으로 로딩되는 동안에 사용자에게 보여질 메세지를 넣어주면 됩니다.End.",
        "url": "/react-lazysuspense"
    }
    ,
    
    "css-blockinline": {
        "title": "block과 inline의 차이점",
            "author": "ykkim97",
            "category": "",
            "content": "CSS는 다음과 같이 구성되어 있습니다.     CSS의 의미와 적용방법    block과 inline의 차이점    em과 rem의 차이    Sass - CSS 전처리기    CSS margin과 padding의 차이block과 inline의 차이오늘은 block과 inline에 대해서 알아보겠습니다.display값으로 여러가지가 있지만 이번글에서는 block과 inline에 대해서만 알아볼 것입니다.display : block먼저 block인데,block은 무조건 한 줄을 모두 차지합니다. 따라서 다음 요소는 줄바꿈이 되게됩니다.div태그가 대표적인 예시입니다.display : inlineinline은 한줄 전체를 차지하는 것이 아니라 해당 텍스트만큼만 자리를 차지합니다. 예로 span태그가 있습니다.inline 태그는 width와 height를 명시할 수 없습니다. 그리고 margin은 위아래엔 적용되지 않고 좌우만 적용됩니다.또한 padding도 보기에는 상하좌우 모두 적용되는 것처럼보이나, 위아래공간은 사실 차지하지 않습니다.display : inline-block마지막으로 inline-block은 inline속성과 block속성을 모두가진 속성입니다. 줄바꿈없이 한 줄에 다른 요소들을 배치할 수 있는 특징이 있고, width, height, margin-top, margin-bottom을 적용할 수 있습니다.End.",
        "url": "/css-blockinline"
    }
    ,
    
    "react-scrolltotop": {
        "title": "React - 페이지 이동시 최상단 스크롤 방법",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React에서 페이지 이동시 최상단 스크롤 방법프로젝트를 진행하던 도중 useNavigate()를 사용해서 페이지를 전환하던 도중에전환된 페이지의 스크롤 위치가 전 페이지의 스크롤 위치와 동일해지는 문제를 발견하였다. 구글에 검색해본 결과 해결방법이 잘 나와있었다.import { useEffect } from \"react\";import { useLocation } from \"react-router-dom\";export default function ScrollToTop() {    const { pathname } = useLocation();    useEffect(() =&gt; {        window.scrollTo(0, 0);    }, [pathname]);    return null;};다음과 같은 코드에 해당하는 ScrollToTop이라는 컴포넌트를 만들고import ScrollToTop from \"./components/common/ScrollToTop\";ReactDOM.render(  &lt;BrowserRouter&gt;    &lt;ScrollToTop /&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;,  document.getElementById('root'));ScrollToTop 컴포넌트를 라우터 내부에 넣어주면 된다.pathname을 인식하게 하기위해 꼭 컴포넌트를 라우터 내부에 넣어야한다고 한다.End.",
        "url": "/react-scrolltotop"
    }
    ,
    
    "react-bootstrapguide": {
        "title": "React Bootstrap 사용하기",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React에서 Bootstrap사용하기React에서 Bootstrap을 사용하는 방법을 알아보겠습니다.일단 Bootstrap을 설치합니다.터미널에 다음과 같이 입력하여 설치합니다.npm install react-bootstrap bootstrap그 다음 최상단 파일인 index.js 또는 App.js에 css를 import해주면됩니다.import 'bootstrap/dist/css/bootstrap.min.css';또는 index.html파일에 다음을 link시켜주면됩니다.&lt;link  rel=\"stylesheet\"  href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\"  integrity=\"sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\"  crossorigin=\"anonymous\"/&gt;React에서 Bootstrap을 사용할 때 주의할 점은 이후에 부트스트랩 컴포넌트를 복사붙여넣기하고 바로 확인해보면 에러가 발생합니다.추가적으로 해야할 것은 붙여넣은 컴포넌트를 따로 import해주어야한다는 것입니다.예시 :import { Navbar, Container, Nav, NavDropdown } from \"react-bootstrap\";이렇게 import하면 정상적으로 사용이 가능합니다.End!",
        "url": "/react-bootstrapguide"
    }
    ,
    
    "react-contextapi": {
        "title": "props가 번거로울 때 Context API를 사용해보자",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해props가 번거로울 때 Context API를 사용해보자React에서 하위컴포넌트에 데이터를 전달하고 싶을 때 우리는 props를 사용하여 하위컴포넌트에 전달합니다.만약 개발을 계속 진행하다가 하위컴포넌트가 많이 추가 될 때 props를 상위 컴포넌트로부터 해당 하위컴포넌트까지 props를 전달해야하는데 정말 번거로울 수 있습니다.이때 사용할 수 있는 방법이 Redux를 사용하거나 Context API를 사용하는 방법이 있습니다.이번 포스팅에서는 Context API에 대해서 알아보겠습니다.Context로 state를 props없이 공유하자.모든 하위 컴포넌트들이 props로 state를 전달하지 않아도 state를 사용할 수 있게 할 수 있습니다.let testContext = React.createContext();function App() {  let [test, setTest] = useState([1,2,3,4]);  return (    // .....code    &lt;testContext.Provider value={test}&gt;      &lt;AnotherComponent /&gt;    &lt;/testContext.Provider&gt;  )}일단 let testContext = React.createContext();와 같이 context를 만듭니다. 이는 “공유할 범위”의 느낌이라고 보면됩니다.위의 test라는 state를 하위컴포넌트인 AnotherComponent와 공유하고 싶을 때 AnotherComponent를 로 감쌉니다.그리고 value값으로 공유하고싶은 state를 작성합니다.그러면 감싸진 범위에 있는 하위 컴포넌트들은 state값을 그냥 가져다 쓸 수 있습니다.import React, {useContext} from 'react';function AnotherComponent(){  return (    // ....code    &lt;Test&gt;&lt;/Test&gt;  )}function Test(){  let hello = useContext(testContext);  return &lt;p&gt;{hello}&lt;/p&gt;}컴포넌트는 AnotherComponent의 하위 컴포넌트입니다. 공유된 state를 사용하려면 위와 같이 useContext Hooks를 변수에 담고, 그 변수를 가지고 데이터바인딩을 하면됩니다.컴포넌트가 외부파일로 분리되어 있다면?만약 하위컴포넌트가 외부파일에 작성되어있다면,export let textContext = React.createContext();이렇게 export를 사용하고 해당 컴포넌트에 import 시켜주면 사용할 수 있습니다.물론 Context API도 상황에 따라서는 오히려 번거로울 수도 있습니다. 상황에 맞게 props나 ContextAPI를 사용하는 것이 좋겠습니다.End.",
        "url": "/react-contextapi"
    }
    ,
    
    "react-gugudan": {
        "title": "React로 간단한 구구단게임 만들기",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React로 간단한 구구단게임 만들기!잠깐 시간을 내어 간단한 구구단게임을 만들어 보았다.기본적으로 React Hooks을 이용하여 만들었다.만들어본 결과는 위 사진과 같다. media query를 이용하여 반응형으로 만들어보았다.기본 구조import { useState } from 'react';import './App.css';function App() {  const [firstNumber, setFirstNumber] = useState(Math.ceil(Math.random() * 9));  const [secondNumber, setSecondNumber] = useState(Math.ceil(Math.random() * 9));  const [value, setValue] = useState(\"\");  const [result, setResult] = useState(\"\");  const onSubmit = (e) =&gt; {    e.preventDefault();    if (value === \"\") {      setResult('숫자를 입력해주세요!');    } else if(parseInt(value) === (firstNumber * secondNumber)) {      setResult('정답!!');      setFirstNumber(Math.ceil(Math.random() * 9));      setSecondNumber(Math.ceil(Math.random() * 9));      setValue(\"\");    } else {      setResult('땡! 다시 입력해보세요!');      setValue(\"\")    }  }  const onChange = (e) =&gt; {    setValue(e.target.value);  }  return (    &lt;div className=\"App\"&gt;      &lt;div className='container'&gt;        &lt;h1&gt;{firstNumber} X {secondNumber} 은?&lt;/h1&gt;        &lt;form onSubmit={onSubmit} className=\"form\"&gt;          &lt;span&gt;            &lt;input               className='input'              type=\"text\"              value={value}               onChange={onChange}            /&gt;          &lt;/span&gt;          &lt;button className='btn'&gt;입력!&lt;/button&gt;          &lt;div className='result'&gt;{result}&lt;/div&gt;        &lt;/form&gt;      &lt;/div&gt;    &lt;/div&gt;  );}export default App;App.js의 내용이다.일단 firstNumber와 secondNumber는 각각 첫 번째 숫자와 두 번째 숫자를 의미하고 value는 입력한 값, 그리고 result는 정답이 아닌지 맞는지 알려주는데 쓰인다.이들을 useState를 이용하여 4개의 state를 만들었다.firstNumber와 secondNumber의 초기값은 1부터 9까지의 랜덤한 값으로 주고 value와 result의 초기값은 빈 값으로 주었다. 입력한 값이 정답인지 판단하는 부분은 onSubmit함수이다.사실 이 부분이 끝이다.const onSubmit = (e) =&gt; {    e.preventDefault();    if (value === \"\") {      setResult('숫자를 입력해주세요!');    } else if(parseInt(value) === (firstNumber * secondNumber)) {      setResult('정답!!');      setFirstNumber(Math.ceil(Math.random() * 9));      setSecondNumber(Math.ceil(Math.random() * 9));      setValue(\"\");    } else {      setResult('땡! 다시 입력해보세요!');      setValue(\"\")    }  }value는 입력한 값이므로, 입력을 하지않고 submit을 했을 경우 숫자를 입력하지 않았기 때문에 ‘숫자를 입력해주세요!’라는 메세지를 띄워준다.그리고 value값이 첫번째수와 두번째수를 곱한 값과 같을 경우 ‘정답!!’이라는 메세지를, 다를 경우 ‘땡! 다시 입력해보세요!’라는 메세지를 보여주게 만들었다.여기서 parseInt(value)를 해준 이유는 value가 문자형이기 때문에 number타입으로 바꾸어 비교하기 위한 것이다.각각의 조건문에 따라 setState함수를 통해 값을 변경해주었다.스타일은 내 생각대로 적절하게 css작업을 했다.어렵지 않게 구구단 웹 게임을 만들어보았다. 완성!!!Sourse Code : https://github.com/ykkim97/React_GuGuDanEnd.",
        "url": "/react-gugudan"
    }
    ,
    
    "typescript-tupletype": {
        "title": "TypeScript - tuple 타입",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?tuple 타입tuple타입 지정하기let food : (string | boolean)[] = ['김치',true];food라는 array가 있습니다. array의 타입지정은 위와 같이 할 수 있습니다.string타입와 boolean타입이 들어갈 수 있는 것입니다. 여기서 첫번째값은 string, 두번째값은 boolean타입만 오도록 타입지정을 더 엄격하게 하고 싶다면 어떻게 할까요? 이럴 때 tuple타입을 쓰면 됩니다.let food : [string,boolean] = ['김치',true];대괄호안에 그 위치에 맞는 타입을 넣으면 됩니다.rest parameter - tuple타입function fun(...x : [string, number]) {    console.log(x);}func('Lee',26);rest parameter도 위와 같이 동일하게 tuple타입을 적용할 수 있습니다.array를 spread 연산자로 합칠 때let arr1 = [1,2,3,4];let arr2 : [number, number, ...number[]] = [5,6,7, ...arr1]array를 spread 연산자로 합칠 때는 위와 같이 타입지정하면 됩니다.tuple타입은 더 정확한 타입지정을 도와줍니다.End.",
        "url": "/typescript-tupletype"
    }
    ,
    
    "typescript-nevertype": {
        "title": "TypeScript - never타입?",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?never타입?타입에는 never타입이라는 것도 있습니다.함수에 붙이는데, 조건이 있습니다.   return을 하면 안됩니다.  함수의 실행이 종료되면 안됩니다.이런 조건을 가진 함수에 붙일 수 있는 타입이 never타입입니다.기본적으로 자바스크립트 함수 맨 마지막에는 “return undefined”가 숨겨져있습니다.따라서 2번조건이 맞는다면 1번도 자동으로 조건이 성립됩니다.function fun() {    console.log(\"hi\");}위의 예시는 return을 하지 않았지만, console.log()로 출력한 이후 함수의 실행이 종료되버리기 때문에 never타입을 쓸 수 없는 것이죠.그러면 도대체 어디에 쓸 수 있을까요?예를 들면 무한반복문일 경우나 에러를 발생시키는 함수가 있습니다.아래와 같이 말이죠.function fun1() {    while(true) {        console.log(\"hi\");    }}function fuc2() {    throw new Error(\"에러\");}사실 never타입은 거의 사용할 일이 없습니다.return을 하고 싶지 않다면 void타입을 사용하면 됩니다.function fun(param : string) {    if (typeof param === \"string\") {        console.log(param);    } else {        console.log(param);    }}위는 never타입이 나타나는 예시를 든 것입니다.fun()의 파라미터인 param의 타입은 “string”으로 지정했는데도 불구하고 narrowing을 사용하여 param이 string타입일 경우와 그렇지 않은 경우를나누어서 코드를 작성했습니다. param이라는 파라미터는 이미 string으로 지정했음에도 굳이 narrowing을 할 필요가 없죠.else안에 param은 never타입이 되있을 것입니다.// 함수선언식function 함수1() {    throw new Error()}//함수표현식let 함수2 = function () {    throw new Error()}또 다른 예시입니다. 함수1()은 함수선언식으로 작성했고 함수2()는 함수표현식으로 작성했습니다.함수1의 경우는 void타입이고, 함수2는 never타입으로 나타나게 됩니다.이번 글에서는 never타입에 대해서 알아보았습니다. 크게 사용할 일은 없겠지만 알아두면 괜찮을 것입니다.End.",
        "url": "/typescript-nevertype"
    }
    ,
    
    "typescript-interface": {
        "title": "TypeScript - interface에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?interface문법1. interface사용법type키워드를 통해서 타입을 변수처럼 작성할 수 있었습니다. “interface”라는 것으로도 할 수 있습니다.interface를 사용하면 Object의 타입을 편하게 지정할 수 있습니다.interface Line {    color : string,    width : number,}let greenLine : Line = { color : \"green\", width : 30 }“Line”이라고 하는 interface명을 지정하고 Object처럼 비슷하게 interface를 정의하면 됩니다.주의할 점은 인터페이스명은 대문자로 시작하여 작명합니다.2. interface의 확장성interface는 extends, 즉 확장이 가능합니다.만약 Animal interface &amp; Dog interface가 필요하다고 가정하면..interface Animal {    name : string,}interface Dog extends Animal{     age : number,}Dog interface 옆에 extends Animal이라고 작성했습니다. 이렇게 되면 Dog interface는 Animal interface를 상속받습니다.Dog interface는 부모의 “name : string”도 가지고 있는 동시에 “age : number”도 가지고 있게 되는 것입니다.3. type와 interface의 차이점?type과 interface의 차이점이 무엇일까요?extends하는 법이 조금 다릅니다.interface의 경우는 위에서 처럼 “extends”를 쓰면됩니다.type의 경우는 “&amp;”을 사용하여 두 object를 합칠 수 있습니다.type Animal = {   name :string } type Dog = Animal &amp; { age : number }그런데 사실 interface의 경우도 “&amp;”기호로 합칠 수 있습니다..주의할점이 있다면 extends를 사용하면 타입끼리 중복속성이 발견될 경우 에러를 내주는데 &amp; 쓰면 때에 따라 아닐 수도 있다는 것입니다.또한 interface는 타입명이 중복되는 것을 허용해주지만, type의 경우 중복선언을 허용하지 않습니다. 엄격하죠.interface는 중복이 될 경우 extends한 것처럼 합쳐집니다. 물론 속성이 중복되면 에러가 나고 type도 마찬가지로 에러가 발생합니다.End.",
        "url": "/typescript-interface"
    }
    ,
    
    "typescript-uniontype": {
        "title": "TypeScript - Union Type, any, unknown",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?Union Type, Any, unknown에 대해이번 글에는 Union Type, Any, unknown에 대해서 알아보겠습니다.Union Type앞서 Union Type에 대해서 언급한 적이 있습니다. Union Type은 “A 또는 B 타입이 들어올 수 있어요”라는 상황에서 사용할 수 있는데 “또는”이라는 것을 나타냅니다.“|” 기호를 통해 나타냅니다.let age : string | number = 100;age라는 변수는 100이라는 number타입을 할당해도 되고, “100”이라는 string타입을 할당해도 되는 것입니다.let arr : (number | string)[] = [\"A\",1,2];let obj : { data : (number | string) } = { data : \"534\" }Array와 Object의 경우에는 위처럼 타입을 정의하면 됩니다.any와 unknownlet aaa : any = 12;any타입은 그 어떤 타입이 와도 OK라는 뜻입니다.타입을 막 바꿔도 에러가 발생하지 않습니다. 에러가 나지 않으니 마냥 좋은 것이 아닙니다. 타입과 관련해서 버그가 발생할 경우 추적하기 힘들어지고타입스크립트를 사용하는 의미가 없는 것이죠. unknown이라는 타입도 있습니다. unknown 역시 any타입처럼 에러가 발생하지 않습니다. 그럼 차이점이 무엇일까요?unknown타입은 any타입을 제외한 다른 타입으로 선언한 변수에 할당할 수 없으며, unknown으로 선언된 변수는 프로퍼티에 접근이 불가하고, 인스턴스를 생성할 수 없습니다.정리하면, 아직 변수에 무엇이 들어갈지 애매할 때, 조금의 안전성을 가져가고 싶다면 unknown타입을 쓰는 것입니다. 많이 쓰진 않지만 any와 unknown에 대해 알아보았습니다.End.",
        "url": "/typescript-uniontype"
    }
    ,
    
    "typescript-basicsyntax": {
        "title": "TypeScript - 기본 타입 작성법",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?타입스크립트 - 타입 작성타입스크립트는 자바스크립트에 타입을 더한 언어입니다. 변수를 만들 때 변수의 타입을 지정가능합니다.변수에 타입 지정하기let myName : string = \"KYG\"myName이란 변수 뒤에 콜론과 함께 string이라는 타입을 적어주었습니다.간단합니다.변수명 : 타입 으로 작성하면되며, myName이라는 변수는 string타입이 된것입니다. 만약 myName변수에 숫자를 할당한다면 어떻게 될까요? 바로 에러가 발생하게 됩니다.타입의 종류에는 string, number, boolean, null, undefined 등이 있습니다.Array와 Object에 타입 지정하기Array와 Object에는 타입을 어떻게 지정할까요?역시 간단합니다.let members :string[] = ['kim', 'Lee','Choi']배열기호인 “[]”와 함께 배열 안에 들어갈 값에 대한 타입을 앞에 적어줍니다.만약에 여러 타입이 동시에 들어올 수 있는 경우는 Union Type을 사용하면되는데 숫자와 문자가 동시에 들어올 수 있다고 가정하면let exam :(string | number)[] = ['kim', 26,'Choi']Object는 어떻게 지정할까요?let 내정보 : { age : number } = { age : 20 }”{}”기호를 사용하고 안에다가 key와 value의 타입을 작성하면 됩니다.그런데 모든 변수에 타입을 지정해야하나요?사실 타입을 굳이 다 적지 않아도 되는데 이유는 변수를 생성할 때 Typescript가 타입을 자동으로 부여해줍니다. 하지만 타입을 적어주는게 좋긴합니다. 오늘은 타입을 지정하는 법을 알아봤습니다.감사합니다.End.",
        "url": "/typescript-basicsyntax"
    }
    ,
    
    "nexjs-redirectrewrite": {
        "title": "(NextJS) redirect와 rewrite",
            "author": "ykkim97",
            "category": "",
            "content": "NextJS는 다음과 같이 구성되어 있습니다.     (NextJS) redirect와 rewrite    오늘은 NextJS의 redirect와 rewrites 사용법에 대해 알아보겠습니다.redirect// next.config.js에 작성합니다./** @type {import('next').NextConfig} */const nextConfig = {  reactStrictMode: true,  async redirects() {    return [      {        source : \"/before\",        destination : \"/after\",        permanent : false      }    ]  }}module.exports = nextConfig위와 같이 사용하면되는데, async redirects로 설정해주어 사용하면됩니다.source부분은 url로 먼저 접근하는 주소이고 destination은 source로 접근할 경우 변경될 주소입니다./before로 접근하면 /after가 되는 것이죠.추가적인 redirect설정을 하고 싶다면 저 묶음을 배열에 추가해주면 됩니다.  참고ex) /before/:path =&gt; /after/:path (:path부분은 기존과 동일한 값으로 유지)ex) /before/:path* =&gt; /after/:path* (*를 붙여주는 경우 어떤값이 오더라도 뒷부분 모두를 반영)rewritesconst nextConfig = {  reactStrictMode: true,  async rewrites() {    return [      {        source : \"/api/movies\",        destination : `https://api.themoviedb.org/3/movie/popular?api_key=${API_KEY}`,      }    ]  }}rewrites는 redirect와 같은 level에 추가하면되고source값으로 불러오면 내부적으로 destination값을 호출하게됩니다.예를 들어, api-key와 같이 숨기고 싶은 값이 url에 있을 경우 실제 url을 숨기고 다른 url로 대체할 수 있습니다.End.",
        "url": "/nexjs-redirectrewrite"
    }
    ,
    
    "typescript-typekeyword": {
        "title": "Type 키워드로 타입을 변수에 담기",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?Type 키워드타입의 정의가 너무 길다면 Type Aliases로!타입스크립트에서 타입을 지정해줄 때 타입이 너무 길거나 작성한 타입이 나중에 재사용될 것 같다면 타입도 변수에 담아쓰는 것이 좋습니다.변수 만드는 것처럼 Type키워드를 사용합니다. 이를 Type Aliases(타입 별칭)이라 합니다.type Food = string | number | undefined;let food : Food = \"apple\";위 처럼 type이라는 키워드를 쓰고 변수에 담으면 끝!보통 타입은 대문자로 시작하는 것이 좋습니다. 이렇게 따로 저장해둔다면 코드 읽기도 편하고 똑같은 코드를 반복해서 적을 필요가 없겠죠?End",
        "url": "/typescript-typekeyword"
    }
    ,
    
    "typescript-asconst": {
        "title": "as const에 대해",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?as const 문법const student = {    name : \"Kim\"}function myFun(a : \"Kim\") {}myFun(student.name);위와 같이 student객체와 myFun이라는 함수를 만들었습니다.myFun함수의 매개변수 a의 타입은 “Kim”타입으로 지정하였습니다. 이후 myFun함수에 student.name을 전달하였습니다. 그런데 이는 에러를 발생시킵니다.student.name이라는 값은 분명 “Kim”인데 왜 에러가 발생하지? 라는 생각이 들 수도 있습니다. 여기서 분명히 해야하는 점은 myFun함수의 매개변수 a는 “Kim”이라는 값만 들어올 수 있다는 의미가 아니라 “Kim”이라는 타입만 들어올 수 있다는 의미입니다.student.name의 값은 “Kim”이지만 타입은 분명 string타입이기 때문에 에러가 발생하는 것입니다.이를 해결하기위한 방법은 여러가지가 있습니다.  student 객체의 타입에 직접 name을 “Kim” 타입으로 지정  Type assertion 사용  student객체에 as const 사용하기let student = {  name : 'kim'} as const;function myFun(a : 'kim') {}myFun(자료.name)위처럼 as const 를 object뒤에 붙이면 에러가 나지 않습니다.as const는 2개의 효과를 가지고 있습니다.  타입을 object의 value로 바꿔줍니다. (타입을 ‘kim’으로 바꿔줍니다)  object안에 있는 속성을 모두 readonly로 바꿔줍니다. (변경하면 에러나도록)이번 포스팅에서는 as const에 대해서 알아보았습니다.감사합니다.End.",
        "url": "/typescript-asconst"
    }
    ,
    
    "typescript-narrowing": {
        "title": "Type Narrowing",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?타입 좁히기 (Type Narrowing)Type Narrowing타입스크립트의 타입은 덜 정확한, 애매한 타입이 있을 수 있습니다. 하지만 타입스크립트는 엄격하기때문에 정확한 타입이 필요합니다. 그렇지 않으면 타입 에러가 발생하게 되죠.이렇게 타입 에러를 막기 위해 Type Narrowing이 필요합니다.Type Narrowing은 if문 등으로 타입을 하나로 정해주는 것입니다.function myFun(x :number | string){  if (typeof x === 'number') {    return x + 1  }   else if (typeof x === 'string') {    return x + 1  }  else {    return 0  }}if문으로 타입을 나누지 않고 그냥 return x + 1 처리하면 에러가 발생합니다.x는 number | string 타입이지 number 타입이나 string 타입이 아니라고 보면됩니다.따라서 조건문으로 타입 별로 처리를 나눠주면 에러를 피할 수 있습니다. 위 코드처럼 조건에 typeof를 꼭 쓸 필요는 없습니다.타입을 하나로 확정지을 수 있는 표현이라면 어떤 것도 Narrowing 역할을 할 수 있습니다.in, instanceof 등의 키워드도 사용이 가능합니다.Type Assertion물론 타입을 간편하게 assert할 수도 있습니다.Type Assertion 이라는 것을 사용하는 것인데, 변수 뒤에 as를 붙이는 것이죠.변수명 as string이렇게 쓰면 “이 변수의 타입을 string으로 생각해주세요”라는 뜻입니다. 하지만 실제로 타입을 바꿔주는 것은 아니기 때문에 조심해서 사용해야합니다.assertion을 남발하는 것은 좋지 않습니다.as 키워드를 사용하면 다음과 같은 특징이 있습니다.  as 키워드는 Union Type과 같은 복잡한 타입을 하나의 정확한 타입으로 좁혀주는 역할을 합니다. 그래서 number타입인 변수를 as string 으로 바꾸려고한다면 에러가 발생합니다.  사실 임시로 타입을 해제시키는 용도입니다. 실제 코드의 실행결과는 as가 있을 때나 없을 때나 동일합니다.정리하자면 as를 사용하면 간편하지만, 정확한 코드를 위해 Narrowing을 사용하는 것이 좋습니다. 왜 타입에러가 나는지 정말 모르겠을 때 임시방편으로 사용하거나, 내가 어떤 타입이 들어올지 확실하게 알고 있으나, 컴파일러 에러가 발생하는 경우 비상용으로 사용하면 되겠습니다.End.",
        "url": "/typescript-narrowing"
    }
    ,
    
    "typescript-basic": {
        "title": "TypeScript란?",
            "author": "ykkim97",
            "category": "",
            "content": "TypeScript은 다음과 같이 구성되어 있습니다.     TypeScript란?    TypeScript - 기본 타입 작성법    TypeScript - Union Type, any, unknown    Type Narrowing    Type 키워드로 타입을 변수에 담기    as const에 대해    TypeScript - interface에 대해    TypeScript - never타입?    TypeScript - tuple타입?1. 타입스크립트(TypeScript)란?타입스크립트(TypeScript)란 자바스크립트(JavaScript)에 타입을 적용한 언어로, 자바스크립트의 확장버전이라고 말할 수도 있을 것입니다.2. 타입스크립트를 쓰는 이유?제가 예시를 들어보겠습니다.문자와 숫자의 연산은 자바스크립트에서 가능합니다.자바스크립트가 알아서 문자를 숫자로 바꿔주기 때문입니다.물론 이러한 자바스크립트의 유연성이 편리할 때도 있습니다. 하지만 코드가 길어져 규모가 커지고 협업을 하는 경우 단점이 됩니다.이러한 경우 타입스크립트를 쓰면 문자와 숫자를 연산할 수 없다는 에러를 띄워줍니다.또한 타입스크립트의 에러메세지는 자바스크립트에 비해서 엄격하게 타입을 체크해주기 때문에 정확하고 추적하기 쉬운 에러메세지를 띄워줍니다. 또한 오타 교정도 해줍니다.3. 타입스크립트 설치기본적인 html,css,js를 가지고 웹 개발을 한다고 가정할 경우  node.js를 설치합니다.(최신버전으로)  에디터 터미널에 npm install -g typescript 입력하여 설치합니다.  .ts로 끝나는 타입스크립트 파일을 생성합니다.  tsconfig.json 파일을 하나 만들어 줍니다.  tsconfig.json 파일안에 다음 코드를 입력합니다.{    \"compilerOptions\" : {        \"target\" : \"es5\",        \"module\" : \"commonjs\",    }}React 프로젝트에서 Typescript 사용할 경우이미 존재하는 React 프로젝트에 설치할 경우에는프로젝트 터미널에서 다음 명령을 입력해주면 됩니다.npm install --save typescript @types/node @types/react @types/react-dom @types/jest그냥 React 프로젝트를 새로만든다면새 프로젝트 폴더를 만들고 에디터 터미널을 열고 다음처럼 입력해주면 됩니다.npx create-react-app my-app --template typescript3. 타입스크립트 컴파일하기타입스크립트 자체는 브라우저가 읽지 못합니다. 따라서 ts파일을 js로 변환해주어야합니다. 컴파일을 하는 것이죠.터미널에tsc -w 라는 명령어를 입력하고 켜놓으면코드를 저장할때마다 js파일로 변환됩니다.파일을 사용할때는 변환된 js파일을 사용합니다.tsconfig.json 파일은 ts에서 js로 컴파일 시에 옵션을 설정할 수 있습니다.",
        "url": "/typescript-basic"
    }
    ,
    
    "react-mkcomponent": {
        "title": "React 컴포넌트 만들기",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해React 컴포넌트 만들기React의 본질은 사용자 정의 태그를 만드는 것입니다.1. 왜?import './App.css';function App() {  return (    &lt;div className='app'&gt;      &lt;header&gt;        &lt;h1&gt;&lt;a href='/'&gt;WEB&lt;/a&gt;&lt;/h1&gt;      &lt;/header&gt;      &lt;nav&gt;        &lt;ol&gt;          &lt;li&gt;&lt;a href='/read/1'&gt;html&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href='/read/1'&gt;css&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href='/read/1'&gt;javascript&lt;/a&gt;&lt;/li&gt;        &lt;/ol&gt;      &lt;/nav&gt;      &lt;article&gt;        &lt;h2&gt;Welcome&lt;/h2&gt;        Hello, WEB      &lt;/article&gt;    &lt;/div&gt;  );}export default App;위의 예시의 경우에는 코드 라인 수가 짧은 편이지만, 규모가 커져 백만 줄, 천만 줄…. 이상으로 라인 수가 길어진다면 한눈에 보기힘들어 가독성이 떨어지고 복잡해집니다. 이로 인해서 코드를 수정하기도 힘들어지게 되겠죠… React의 본질은 사용자 정의 태그를 만드는 것입니다.2. 방법function App() {  return (    &lt;div className='app'&gt;      &lt;Header /&gt;      &lt;Nav /&gt;      &lt;Article /&gt;    &lt;/div&gt;  );}간단해진 App 컴포넌트위와 같이 &lt;Header&gt; , &lt;Nav&gt; , &lt;Article&gt;로 코드를 짧게 줄일 수 있습니다.아래와 같이 각각 함수로 만들어 주면 됩니다.function Header() {  return (    &lt;header&gt;      &lt;h1&gt;&lt;a href='/'&gt;WEB&lt;/a&gt;&lt;/h1&gt;    &lt;/header&gt;  )}function Nav() {  return (    &lt;nav&gt;      &lt;ol&gt;        &lt;li&gt;&lt;a href='/read/1'&gt;html&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href='/read/1'&gt;css&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href='/read/1'&gt;javascript&lt;/a&gt;&lt;/li&gt;      &lt;/ol&gt;    &lt;/nav&gt;  )}function Article() {  return (    &lt;article&gt;      &lt;h2&gt;Welcome&lt;/h2&gt;      Hello, WEB    &lt;/article&gt;  )}function App() {  return (    &lt;div className='app'&gt;      &lt;Header /&gt;      &lt;Nav /&gt;      &lt;Article /&gt;    &lt;/div&gt;  );}함수로 만들 때 주의할 사항은 함수명(컴포넌트)은 항상 대문자로 시작해야 한다는 것입니다.일반 html태그와 차이를 주는 것입니다.함수를 만들고 App컴포넌트에 일반 태그 쓰듯이 붙여주면 됩니다.이렇게 하면 코드의 가독성도 좋고 코드를 반복해서 사용할 필요없이 계속해서 컴포넌트를 독립된 부품처럼 가져다 쓸 수 있습니다.또한 컴포넌트를 공유할 수 있으므로 생산성도 높아집니다.",
        "url": "/react-mkcomponent"
    }
    ,
    
    "css-basic": {
        "title": "CSS의 의미와 적용방법",
            "author": "ykkim97",
            "category": "",
            "content": "CSS는 다음과 같이 구성되어 있습니다.     CSS의 의미와 적용방법    block과 inline의 차이점    em과 rem의 차이    Sass - CSS 전처리기    CSS margin과 padding의 차이1. CSS란?CSS는 Cascading Style Sheets 라는 의미로, html에 스타일을 지정할 때 사용하는 언어입니다.CSS를 사용하는 방법은 내부 스타일시트, 외부 스타일시트, 인라인 스타일시트가 있습니다.2. 내부 스타일시트내부 스타일시트는 말 그대로 html문서 내부에 css를 직접 작성하는 방법입니다.아래처럼 head태그안에 style태그를 입력하고 그 안에 css 스타일링을 해주면 됩니다.간편하게 사용할 수 있는 장점이 있습니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        p {            color: tomato;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;안녕하세요!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;3. 외부 스타일시트확장자가 .css로 끝나는 별도의 파일을 만들어 연결하는 방법입니다.p {    color: tomato;}위처럼 따로 css파일을 만들고,&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;안녕하세요!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;link 태그의 href속성에 css파일의 경로를 적어주면 끝!4. 인라인 스타일시트&lt;body&gt;    &lt;p style=\"color: tomato;\"&gt;안녕하세요!&lt;/p&gt;&lt;/body&gt;인라인 스타일시트는 html태그의 속성에 바로 스타일을 작성하는 방법입니다.End.",
        "url": "/css-basic"
    }
    ,
    
    "html-basic-tags": {
        "title": "HTML 기본 태그들",
            "author": "ykkim97",
            "category": "",
            "content": "HTML은 다음과 같이 구성되어 있습니다.     웹의 기본중의 기본! HTML에 대해서 알아보자    HTML 기본 태그들    DOCTYPE의 의미?    시맨틱 태그?HTML 기본 태그들1. &lt;head&gt;1) 태그문서의 정보를 담고 있는 태그로 웹을 설계하고 구축할 때 필수적으로 들어가야 되는 문서의 정보입니다.2) 태그문서의 제목을 나타내는 태그입니다. 웹페이지 탭을 띄우게 되면 웹의 제목이 나타나게 됩니다.3) 태그주로 css 파일을 연결할 때 사용합니다. 물론 다른 외부요소를 연결하는 데에도 사용합니다.4) ",
        "url": "/html-basic-tags"
    }
    ,
    
    "html-basic": {
        "title": "웹의 기본중의 기본! HTML에 대해서 알아보자",
            "author": "ykkim97",
            "category": "",
            "content": "HTML은 다음과 같이 구성되어 있습니다.     웹의 기본중의 기본! HTML에 대해서 알아보자    HTML 기본 태그들    DOCTYPE의 의미?    시맨틱 태그?HTML은 HyperText Markup Language의 약자로 웹을 이루는 가장 기초적인 구성요소입니다. 웹 컨텐츠의 의미와 구조를 정의할 때 사용합니다.HTML로 기본 구조를 잡고 CSS로 스타일링 하며 기능 및 동작은 JavaScript를 이용하게 됩니다.HTML요소의 형식은 다음과 같습니다. 컨텐츠 위 처럼 태그안에 컨텐츠가 들어가게 되고, 태그에는 여러 속성들이 들어갈 수 있습니다.물론 위처럼 열고 닫는 태그만 존재하는 것은 아닙니다.컨텐츠가 없는 태그도 존재하죠.이를 빈 태그(Empty Tag)라고도 합니다.HTML 문서는 파일의 확장자가 html로 끝나며 최상위 태그로 &lt;html&gt;을 사용한다. 그 하위에 &lt;head&gt; 태그와 &lt;body&gt; 태그를 컨텐츠로 가지고 있습니다. 태그는 문서를 설명하는 태그로 제목이나 키워드와 같은 정보를 담고  태그에는 문서의 내용이 위치합니다.",
        "url": "/html-basic"
    }
    ,
    
    "react-basic": {
        "title": "React란?",
            "author": "ykkim97",
            "category": "",
            "content": "React은 다음과 같이 구성되어 있습니다.     React란?    React 컴포넌트 만들기    useState에 대해    React로 간단한 구구단게임 만들기!    props가 번거로울 때 Context API를 사용해보자    React에서 Bootstrap사용하기    React 페이지 이동시 최상단 스크롤 방법    React - lazy, Suspense에 대해1. ReactReact는 Facebook에서 제공 중인 자바스크립트 라이브러리이자 웹 프레임워크이다.React를 사용하지 않더라도 HTML, CSS, JS 만으로도 웹페이지를 만들 수 있지만 React를 이용해 사용자와 상호 작용할 수 있는 동적인 UI를 쉽게 개발할 수 있기 때문에 많이 사용된다. React 말고도 Vue나 Angular와 같은 프레임워크들이 사용되고 있는데 현재 가장 많이 사용되고 있는 것은 React인 것이다.2. React의 특징1. Data flowReact는 단방향 데이터 흐름을 가지고 있다고 한다.Angular.js와 같은 양방향 데이터 바인딩은 개발 규모가 커질수록 데이터의 흐름을 추적하기 힘들고 복잡해질 수 있지만 React의 경우는 복잡한 어플리케이션의 경우에도 데이터 흐름에서 일어나는 변화를 보다 예측 가능하도록 단방향 흐름을 가지도록 했다고함.2. 컴포넌트 기반 구조컴포넌트란 독립적인 소프트웨어 모듈을 의미한다.React의 경우 UI를 여러 개의 컴포넌트로 나누어서 개발한다. 즉 여러 컴포넌트를 모아서 하나의 페이지를 구성하는 것이다. 컴포넌트 별로 나누어져 있기 때문에 전체 코드를 파악하기 쉽다.그리고 코드를 반복해서 작성할 필요없이 컴포넌트를 import하여 간단히 사용할 수 있다.애플리케이션이 복잡해지더라도 코드의 관리와 유지보수가 용이하다는 장점이 있다.3. Virtual DOMDOM은 Documnet Object Model이며 html,css,xml등을 트리 구조로 인식하고 데이터를 객체로 간주하고 관리한다.React는 이 DOM TREE 구조와 같은 구조체를 Virtual DOM으로 가지고 있다. Virtual DOM은 가상의 DOM으로 이벤트가 발생할 떄 마다 Virtual DOM을 만들고 다시 그릴 때마다 실제 DOM과 비교하여 변경이 필요한 최소한의 변경사항만 실제 DOM에 반영하여 어플리케이션의 효율성과 속도를 개선할 수 있다고 한다.4. Props 와 State      Props    Props는 부모 컴포넌트에서 자식 컴포넌트로 전달해주는 데이터이다.    쉽게 읽기 전용 데이터라고 생각하면 될 것 같다. 자식 컴포넌트에서 전달받은 props는 변경이 불가능하고 props를 전달해준 최상위 부모 컴포넌트만 props를 변경할 수 있습니다.        State    State는 컴포넌트 내부에서 선언하며 내부에서 값을 변경할 수 있습니다. state는 동적인 데이터를 다룰 때 사용하며, 사용자와의 상호작용을 통해 데이터를 동적으로 변경할 때 사용합니다.  5. JSXReact는 JSX문법을 사용할 수 있는데 Javascript에 XML을 추가한 확장한 문법이라고 보면 된다.",
        "url": "/react-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ykkim97.github.io/">YoungGwon's IT Tech Blog</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search YoungGwon's IT Tech Blog</h1>
            <p class="subscribe-overlay-description">
            포스트 검색하기 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
                id="searchtext" type="text" name="searchtext"  
                placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
